//*************
//***ENTITIES**
//*************

@spice @genType.as("Id")
type id = string

@genType.import(("./bindings/OpaqueTypes", "Nullable"))
type nullable<'a> = option<'a>

let nullable_encode = (encoder: Spice.encoder<'a>, n: nullable<'a>): Js.Json.t =>
  switch n {
  | None => Js.Json.null
  | Some(v) => v->encoder
  }

let nullable_decode = Spice.optionFromJson

@@warning("-30")
@genType
type rec {{#each entities as | entity |}}{{#unless @first}}
and {{/unless}}{{entity.name.uncapitalized}}LoaderConfig = {{#if entity.relational_params.filtered_not_derived_from.[0]}}{
  {{#each entity.relational_params.filtered_not_derived_from as | relational_param |}}
  load{{relational_param.relational_key.capitalized}}?: {{relational_param.mapped_entity.uncapitalized}}LoaderConfig,{{/each}}
}{{else}}bool{{/if}}{{/each}}

@@warning("+30")
@genType
type entityRead = 
{{#each entities as | entity |}}
| {{entity.name.capitalized}}Read(id{{#if entity.relational_params.filtered_not_derived_from.[0]}}, {{entity.name.uncapitalized}}LoaderConfig{{/if}})
{{/each}}

@genType
type rawEventsEntity = {
  @as("chain_id") chainId: int,
  @as("event_id") eventId: string,
  @as("block_number") blockNumber: int,
  @as("log_index") logIndex: int,
  @as("transaction_index") transactionIndex: int,
  @as("transaction_hash") transactionHash: string,
  @as("src_address") srcAddress: Ethers.ethAddress,
  @as("block_hash") blockHash: string,
  @as("block_timestamp") blockTimestamp: int,
  @as("event_type") eventType: Js.Json.t,
  params: string,
}

@genType
type dynamicContractRegistryEntity = {
  @as("chain_id") chainId: int,
  @as("event_id") eventId: Ethers.BigInt.t,
  @as("contract_address") contractAddress: Ethers.ethAddress,
  @as("contract_type") contractType: string,
}


{{#each entities as | entity |}}
@spice @genType.as("{{entity.name.original}}Entity")
type {{entity.name.uncapitalized}}Entity = {
  {{#each entity.params as | param |}}
  {{#unless param.is_derived_from }}{{param.field_name.uncapitalized}}: {{param.type_rescript_nullable}}, {{/unless}}
  {{/each}}
}
 
{{/each}}
type entity = 
{{#each entities as | entity |}}
  | {{entity.name.capitalized}}Entity({{entity.name.uncapitalized}}Entity)
{{/each}}

type dbOp = Read | Set | Delete

@genType
type inMemoryStoreRow<'a> = {
  dbOp: dbOp,
  entity: 'a,
}

//*************
//**CONTRACTS**
//*************

@genType.as("EventLog")
type eventLog<'a> = {
  params: 'a,
  chainId: int,
  blockNumber: int,
  blockTimestamp: int,
  blockHash: string,
  srcAddress: Ethers.ethAddress,
  transactionHash: string,
  transactionIndex: int,
  logIndex: int,
}

{{#each codegen_contracts as | contract |}}
module {{contract.name.capitalized}}Contract = {
{{#each contract.codegen_events as | event |}}
module {{event.name.capitalized}}Event = {
  //Note: each parameter is using a binding of its index to help with binding in ethers
  //This handles both unamed params and also named params that clash with reserved keywords
  //eg. if an event param is called "values" it will clash since eventArgs will have a '.values()' iterator
  type ethersEventArgs = 
    {{#if event.params}}
    {
      {{#each event.params as | param |}}
      @as("{{@index}}") {{param.param_name.uncapitalized}}: {{param.type_rescript}},
      {{/each}}
    }
    {{else}}
    unit
    {{/if}}

  @spice @genType
  type eventArgs = 
    {{#if event.params}}
    {
      {{#each event.params as | param |}}
      {{param.param_name.uncapitalized}}: {{param.type_rescript}},
      {{/each}}
    }
    {{else}}
    unit
    {{/if}}


  @genType.as("{{contract.name.capitalized}}Contract_{{event.name.capitalized}}_EventLog")
  type log = eventLog<eventArgs>

    {{#each ../../entities as | entity |}}

    // Entity: {{entity.name.original}}
    type {{entity.name.uncapitalized}}EntityHandlerContext = {
    {{#each event.required_entities as | required_entity |}}
      {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
        {{#if required_entity.labels}}
        {{#each required_entity.labels as |label| }}
        {{label}}: option<{{required_entity.name.uncapitalized}}Entity>,
        {{/each}}
        {{/if}}
        {{#if required_entity.array_labels}}
        {{#each required_entity.array_labels as |array_label| }}
        {{array_label}}: array<option<{{required_entity.name.uncapitalized}}Entity>>,
        {{/each}}
        {{/if}}
        get: id => option<{{required_entity.name.uncapitalized}}Entity>,
      {{/if}}

    {{/each}}
    {{#each entity.relational_params.filtered_not_derived_from as | entity_field |}}
        get{{entity_field.relational_key.capitalized}}: {{entity.name.uncapitalized}}Entity => 
        {{#if entity_field.is_optional}}
          option<{{entity_field.mapped_entity.uncapitalized}}Entity>
        {{else}}
          {{#if entity_field.is_array}}
            array<{{entity_field.mapped_entity.uncapitalized}}Entity>
          {{else}}
            {{entity_field.mapped_entity.uncapitalized}}Entity
          {{/if}}
        {{/if}},
      {{/each}}
      set: {{entity.name.uncapitalized}}Entity => unit,
      delete: id => unit,
    }

    type {{entity.name.uncapitalized}}EntityHandlerContextAsync = {
    {{#each event.required_entities as | required_entity |}}
      {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
        {{#if required_entity.labels}}
        {{#each required_entity.labels as |label| }}
        {{label}}: option<{{required_entity.name.uncapitalized}}Entity>,
        {{/each}}
        {{/if}}
        {{#if required_entity.array_labels}}
        {{#each required_entity.array_labels as |array_label| }}
        {{array_label}}: array<option<{{required_entity.name.uncapitalized}}Entity>>,
        {{/each}}
        {{/if}}
        get: id => promise<option<{{required_entity.name.uncapitalized}}Entity>>,
      {{/if}}

    {{/each}}
    {{#each entity.relational_params.filtered_not_derived_from as | entity_field |}}
        get{{entity_field.relational_key.capitalized}}: {{entity.name.uncapitalized}}Entity => 
        promise<{{#if entity_field.is_optional}}
          option<{{entity_field.mapped_entity.uncapitalized}}Entity>,
        {{else}}
          {{#if entity_field.is_array}}
          {{!-- NOTE: this case is currently impossible. However, we should make this work for `derivedFrom` fields. - see: https://github.com/Float-Capital/indexer/issues/1168 --}}
            array<{{entity_field.mapped_entity.uncapitalized}}Entity>,
          {{else}}
            {{entity_field.mapped_entity.uncapitalized}}Entity,
          {{/if}}
        {{/if}}
        >,
      {{/each}}
      set: {{entity.name.uncapitalized}}Entity => unit,
      delete: id => unit,
    }
    {{/each}}

    @genType
    type handlerContext = {
      log: Logs.userLogger,
      {{#each ../../entities as | entity |}}
        @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: {{entity.name.uncapitalized}}EntityHandlerContext,
      {{/each}}
    }
    @genType
    type handlerContextAsync = {
      log: Logs.userLogger,
      {{#each ../../entities as | entity |}}
        @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: {{entity.name.uncapitalized}}EntityHandlerContextAsync,
      {{/each}}
    }

    {{#each event.required_entities as | required_entity |}}
    @genType
    type {{required_entity.name.uncapitalized}}EntityLoaderContext = {
      {{#if required_entity.labels}}
      {{#each required_entity.labels as | label |}}
      {{label}}Load: (id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders: {{required_entity.name.uncapitalized}}LoaderConfig=?{{/if}}) => unit,
      {{/each}}
      {{/if}}
      {{#if required_entity.array_labels}}
      {{#each required_entity.array_labels as | array_label |}}
      {{array_label}}Load: (array<id>{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders: {{required_entity.name.uncapitalized}}LoaderConfig=?{{/if}}) => unit,
      {{/each}}
      {{/if}}
      load: (id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders: {{required_entity.name.uncapitalized}}LoaderConfig=?{{/if}}) => unit,
    }
    {{/each}}

    
    @genType
    type contractRegistrations = {
    {{#each ../../codegen_contracts as |contract_inner| }}
      //TODO only add contracts we've registered for the event in the config
      add{{contract_inner.name.capitalized}}: (Ethers.ethAddress) => unit,
    {{/each}}
    }
    @genType
    type loaderContext = {
      log: Logs.userLogger,
      contractRegistration: contractRegistrations,
    {{#each event.required_entities as | required_entity |}}
      @as("{{required_entity.name.original}}") {{required_entity.name.uncapitalized}} : {{required_entity.name.uncapitalized}}EntityLoaderContext,
    {{/each}}
    }
}
{{/each}}
}
{{/each}}

@deriving(accessors)
type event =
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | {{contract.name.capitalized}}Contract_{{event.name.capitalized}}(eventLog<{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>)
{{/each}}
{{/each}}

@spice
type eventName =
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | @spice.as("{{event.event_type.truncated_for_pg_enum_limit}}") {{event.event_type.full}}
{{/each}}
{{/each}}

let eventNameToString = (eventName: eventName) => switch eventName {
  {{#each codegen_contracts as | contract |}}
  {{#each contract.codegen_events as | event |}}
    | {{event.event_type.full}} => "{{event.name.capitalized}}"
  {{/each}}
  {{/each}}
}

@genType
type chainId = int

type eventBatchQueueItem = {
  timestamp: int,
  chain: ChainMap.Chain.t,
  blockNumber: int,
  logIndex: int,
  event: event,
  //Default to false, if an event needs to
  //be reprocessed after it has loaded dynamic contracts
  //This gets set to true and does not try and reload events
  hasRegisteredDynamicContracts?: bool,
}
