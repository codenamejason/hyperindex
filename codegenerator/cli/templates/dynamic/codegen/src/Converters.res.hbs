exception UndefinedEvent(string)

let getVal = (_typ, _fn) =>
  %raw(`
    Array.isArray(_typ) ?
       _typ.map(inner => getVal(inner, _fn)) : _typ.val
`)

let eventStringToEvent = (eventName: string, contractName: string): Types.eventName => {
  switch (eventName, contractName) {
    {{#each codegen_contracts as |contract|}}
    {{#each contract.codegen_events as |event|}}
    | ("{{event.name.capitalized}}", "{{contract.name.capitalized}}") => {{event.event_type.full}}
    {{/each}}
    {{/each}}
    | _ => UndefinedEvent(eventName)->raise
  }
}

{{#each codegen_contracts as |contract|}}
module {{contract.name.capitalized}} = {
{{#each contract.codegen_events as |event|}}
  let convert{{event.name.capitalized}}ViemDecodedEvent: Viem.decodedEvent<'a> => Viem.decodedEvent<
    Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs,
  > = Obj.magic

  {{#unless event.params}}
  @warning("-27")
  {{/unless}}
  let convert{{event.name.capitalized}}LogDescription = (log: Ethers.logDescription<'a>): Ethers.logDescription<
    Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs,
  > => {
    //Convert from the ethersLog type with indexs as keys to named key value object
    let ethersLog: 
      Ethers.logDescription<
        Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.ethersEventArgs
      >
      = log->Obj.magic
    let {args, name, signature, topic} = ethersLog

      {
        name,
        signature,
        topic,
        {{#if event.params}}
        args: {
        {{#each event.params as | param |}}
          {{param.param_name.uncapitalized}}: args.{{param.param_name.uncapitalized}},
        {{/each}}
        }
        {{else}}
        args: ()
        {{/if}}
      }
  }
  
  {{#unless event.params}}
  @warning("-27")
  {{/unless}}
  let convert{{event.name.capitalized}}Log = (
    logDescription: Ethers.logDescription<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>,
    ~log: Ethers.log,
    ~blockTimestamp: int,
    ~chainId: int,
  ) => {
    let params: Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs = 
    {{#if event.params}}
    {
      {{#each event.params as | param |}}
        {{param.param_name.uncapitalized}}: logDescription.args.{{param.param_name.uncapitalized}},
      {{/each}}
    }
    {{else}}
    ()
    {{/if}}

    let {{event.name.uncapitalized}}Log: Types.eventLog<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs> = {
      params,
      chainId,
      blockNumber: log.blockNumber,
      blockTimestamp,
      blockHash: log.blockHash,
      srcAddress: log.address,
      transactionHash: log.transactionHash,
      transactionIndex: log.transactionIndex,
      logIndex: log.logIndex,
    }

    Types.{{contract.name.capitalized}}Contract_{{event.name.capitalized}}({{event.name.uncapitalized}}Log)
  }
  {{#unless event.params}}
  @warning("-27")
  {{/unless}}
  let convert{{event.name.capitalized}}LogViem = (
    decodedEvent: Viem.decodedEvent<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>,
    ~log: Ethers.log,
    ~blockTimestamp: int,
    ~chainId: int,
  ) => {
    let params: Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs = 
    {{#if event.params}}
    {
      {{#each event.params as | param |}}
        {{param.param_name.uncapitalized}}: decodedEvent.args.{{param.param_name.uncapitalized}},
      {{/each}}
    }
    {{else}}
    ()
    {{/if}}

    let {{event.name.uncapitalized}}Log: Types.eventLog<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs> = {
      params,
      chainId,
      blockNumber: log.blockNumber,
      blockTimestamp,
      blockHash: log.blockHash,
      srcAddress: log.address,
      transactionHash: log.transactionHash,
      transactionIndex: log.transactionIndex,
      logIndex: log.logIndex,
    }

    Types.{{contract.name.capitalized}}Contract_{{event.name.capitalized}}({{event.name.uncapitalized}}Log)
  }

  {{#if event.indexed_params[0]}}
    type decoded{{event.name.capitalized}}Indexed = {
      {{#each event.indexed_params as | param |}}
        @as("{{@index}}") {{param.param_name.uncapitalized}}: {{param.type_rescript_skar_decoded_param}},
      {{/each}}
    }
  {{/if}}

  {{#if event.body_params[0]}}
    type decoded{{event.name.capitalized}}Body = {
      {{#each event.body_params as | param |}}
        @as("{{@index}}") {{param.param_name.uncapitalized}}: {{param.type_rescript_skar_decoded_param}},
      {{/each}}
    }
  {{/if}}

  let convert{{event.name.capitalized}}DecodedEventParams = (
    decodedEvent: HyperSyncClient.Decoder.decodedEvent<'a>,
  ): Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs => {
    {{#if event.indexed_params[0]}}
      let {
        {{#each event.indexed_params as | param |}}
          {{param.param_name.uncapitalized}},
        {{/each}}
      }: decoded{{event.name.capitalized}}Indexed = decodedEvent.indexed->Obj.magic
    {{/if}}

    {{#if event.body_params[0]}}
      let {
        {{#each event.body_params as | param |}}
          {{param.param_name.uncapitalized}},
        {{/each}}
      }: decoded{{event.name.capitalized}}Body = decodedEvent.body->Obj.magic
    {{/if}}

    {
      {{#each event.params as | param |}}
        {{param.param_name.uncapitalized}}: {{param.param_name.uncapitalized}}->getVal(getVal),
      {{/each}}
    }
  }
{{/each}}
}

{{/each}}

type parseEventError =
  ParseError(Ethers.Interface.parseLogError) | UnregisteredContract(Ethers.ethAddress)

exception ParseEventErrorExn(parseEventError)

let parseEventEthers = (~log, ~blockTimestamp, ~contractInterfaceManager, ~chainId): Belt.Result.t<
  Types.event,
  _,
> => {
  let logDescriptionResult = contractInterfaceManager->ContractInterfaceManager.parseLogEthers(~log)
  switch logDescriptionResult {
  | Error(e) =>
    switch e {
    | ParseError(parseError) => ParseError(parseError)
    | UndefinedInterface(contractAddress) => UnregisteredContract(contractAddress)
    }->Error

  | Ok(logDescription) =>
    switch contractInterfaceManager->ContractInterfaceManager.getContractNameFromAddress(
      ~contractAddress=log.address,
    ) {
    | None => Error(UnregisteredContract(log.address))
    | Some(contractName) =>
      let event = switch eventStringToEvent(logDescription.name, contractName) {
      {{#each codegen_contracts as |contract|}}
      {{#each contract.codegen_events as |event|}}
        | {{event.event_type.full}} =>
            logDescription
            ->{{contract.name.capitalized}}.convert{{event.name.capitalized}}LogDescription
            ->{{contract.name.capitalized}}.convert{{event.name.capitalized}}Log(~log, ~blockTimestamp, ~chainId)
      {{/each}}
      {{/each}}
      }

      Ok(event)
    }
  }
}

let parseEvent = (~log, ~blockTimestamp, ~contractInterfaceManager, ~chainId): Belt.Result.t<
  Types.event,
  _,
> => {
 let decodedEventResult = contractInterfaceManager->ContractInterfaceManager.parseLogViem(~log)
  switch decodedEventResult {
  | Error(e) =>
    switch e {
    | ParseError(parseError) => ParseError(parseError)
    | UndefinedInterface(contractAddress) => UnregisteredContract(contractAddress)
    }->Error

  | Ok(decodedEvent) =>
    switch contractInterfaceManager->ContractInterfaceManager.getContractNameFromAddress(
      ~contractAddress=log.address,
    ) {
    | None => Error(UnregisteredContract(log.address))
    | Some(contractName) =>
      let event = switch eventStringToEvent(decodedEvent.eventName, contractName) {
      {{#each codegen_contracts as |contract|}}
      {{#each contract.codegen_events as |event|}}
        | {{event.event_type.full}} =>
            decodedEvent
            ->{{contract.name.capitalized}}.convert{{event.name.capitalized}}ViemDecodedEvent
            ->{{contract.name.capitalized}}.convert{{event.name.capitalized}}LogViem(~log, ~blockTimestamp, ~chainId)
      {{/each}}
     {{/each}}
      }

      Ok(event)
    }
  }
}

let decodeRawEventWith = (
  rawEvent: Types.rawEventsEntity,
  ~decoder: Spice.decoder<'a>,
  ~variantAccessor: Types.eventLog<'a> => Types.event,
  ~chain,
): Spice.result<Types.eventBatchQueueItem> => {
  switch rawEvent.params->Js.Json.parseExn {
  | exception exn =>
    let message =
      exn
      ->Js.Exn.asJsExn
      ->Belt.Option.flatMap(jsexn => jsexn->Js.Exn.message)
      ->Belt.Option.getWithDefault("No message on exn")

    Spice.error(`Failed at JSON.parse. Error: ${message}`, rawEvent.params->Obj.magic)
  | v => Ok(v)
  }
  ->Belt.Result.flatMap(json => {
    json->decoder
  })
  ->Belt.Result.map(params => {
    let event = {
      chainId: rawEvent.chainId,
      blockNumber: rawEvent.blockNumber,
      blockTimestamp: rawEvent.blockTimestamp,
      blockHash: rawEvent.blockHash,
      srcAddress: rawEvent.srcAddress,
      transactionHash: rawEvent.transactionHash,
      transactionIndex: rawEvent.transactionIndex,
      logIndex: rawEvent.logIndex,
      params,
    }->variantAccessor

    let queueItem: Types.eventBatchQueueItem = {
      timestamp: rawEvent.blockTimestamp,
      chain,
      blockNumber: rawEvent.blockNumber,
      logIndex: rawEvent.logIndex,
      event,
    }

    queueItem
  })
}

let parseRawEvent = (rawEvent: Types.rawEventsEntity, ~chain): Spice.result<
  Types.eventBatchQueueItem,
> => {
  rawEvent.eventType
  ->Types.eventName_decode
  ->Belt.Result.flatMap(eventName => {
    switch eventName {
  {{#each codegen_contracts as |contract|}}
  {{#each contract.codegen_events as |event|}}
      | {{event.event_type.full}} =>
      rawEvent->decodeRawEventWith(
        ~decoder=Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs_decode,
        ~variantAccessor=Types.{{contract.name.uncapitalized}}Contract_{{event.name.capitalized}},
        ~chain,
      )
  {{/each}}
  {{/each}}
    }
  })
}
