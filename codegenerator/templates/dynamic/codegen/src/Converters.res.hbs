exception UndefinedEvent(string)

let eventStringToEvent = (eventName: string, contractName: string): Types.eventName => {
  switch (eventName, contractName) {
    {{#each contracts as |contract|}}
    {{#each contract.events as |event|}}
    | ("{{event.name.capitalized}}", "{{contract.name.capitalized}}") => {{contract.name.capitalized}}Contract_{{event.name.capitalized}}Event
    {{/each}}
    {{/each}}
    | _ => UndefinedEvent(eventName)->raise
  }
}

{{#each contracts as |contract|}}
module {{contract.name.capitalized}} = {
{{#each contract.events as |event|}}
  let convert{{event.name.capitalized}}LogDescription = (log: Ethers.logDescription<'a>): Ethers.logDescription<
    Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs,
  > => {
    //Convert from the ethersLog type with indexs as keys to named key value object
    let ethersLog: 
      Ethers.logDescription<
        Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.ethersEventArgs
      >
      = log->Obj.magic
    let {args, name, signature, topic} = ethersLog

      {
        name,
        signature,
        topic,
        args: {
        {{#each event.params as | param |}}
          {{param.key}}: args.{{param.key}},
        {{/each}}
        }
      }
  }

  let convert{{event.name.capitalized}}Log = (
    logDescription: Ethers.logDescription<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>,
    ~log: Ethers.log,
    ~blockTimestamp: int,
  ) => {
    let params: Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs = {
      {{#each event.params as | param |}}
        {{param.key}}: logDescription.args.{{param.key}},
      {{/each}}
    }

    let {{event.name.uncapitalized}}Log: Types.eventLog<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs> = {
      params,
      blockNumber: log.blockNumber,
      blockTimestamp,
      blockHash: log.blockHash,
      srcAddress: log.address,
      transactionHash: log.transactionHash,
      transactionIndex: log.transactionIndex,
      logIndex: log.logIndex,
    }

    Types.{{contract.name.capitalized}}Contract_{{event.name.capitalized}}({{event.name.uncapitalized}}Log)
  }

{{/each}}
}

{{/each}}

type parseEventError =
  ParseError(Ethers.Interface.parseLogError) | UnregisteredContract(Ethers.ethAddress)

let parseEvent = (~log, ~blockTimestamp, ~contractInterfaceManager): Belt.Result.t<
  Types.event,
  _,
> => {
  let logDescriptionResult = contractInterfaceManager->ContractInterfaceManager.parseLog(~log)
  switch logDescriptionResult {
  | Error(e) =>
    switch e {
    | EthersParseError(parseError) => ParseError(parseError)
    | UndefinedInterface(contractAddress) => UnregisteredContract(contractAddress)
    }->Error

  | Ok(logDescription) =>
    switch contractInterfaceManager->ContractInterfaceManager.getContractNameFromAddress(
      ~contractAddress=log.address,
    ) {
    | None => Error(UnregisteredContract(log.address))
    | Some(contractName) =>
      let event = switch eventStringToEvent(logDescription.name, contractName) {
      {{#each contracts as |contract|}}
      {{#each contract.events as |event|}}
        | {{contract.name.capitalized}}Contract_{{event.name.capitalized}}Event =>
            logDescription
            ->{{contract.name.capitalized}}.convert{{event.name.capitalized}}LogDescription
            ->{{contract.name.capitalized}}.convert{{event.name.capitalized}}Log(~log, ~blockTimestamp)
      {{/each}}
      {{/each}}
      }

      Ok(event)
    }
  }
}
