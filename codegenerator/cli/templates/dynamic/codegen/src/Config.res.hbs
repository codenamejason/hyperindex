type contract = {
  name: string,
  abi: Ethers.abi,
  addresses: array<Ethers.ethAddress>,
  events: array<Types.eventName>,
}

type syncConfig = {
  initialBlockInterval: int,
  backoffMultiplicative: float,
  accelerationAdditive: int,
  intervalCeiling: int,
  backoffMillis: int,
  queryTimeoutMillis: int,
}

type serverUrl = string

type rpcConfig = {
  provider: Ethers.JsonRpcProvider.t,
  syncConfig: syncConfig,
}

/**
A generic type where for different values of HyperSync and Rpc.
Where first param 'a represents the value for hypersync and the second
param 'b for rpc
*/
type source<'a, 'b> = HyperSync('a) | Rpc('b)

type syncSource = source<serverUrl, rpcConfig>

type chainConfig = {
  syncSource: syncSource,
  startBlock: int,
  endBlock: option<int>,
  confirmedBlockThreshold: int,
  chain: ChainMap.Chain.t,
  contracts: array<contract>,
}

type chainConfigs = ChainMap.t<chainConfig>

type historyFlag = FullHistory | MinHistory
type rollbackFlag = RollbackOnReorg | NoRollback
type historyConfig = {rollbackFlag: rollbackFlag, historyFlag: historyFlag}

let makeHistoryConfig = (~shouldRollbackOnReorg, ~shouldSaveFullHistory) => {
  rollbackFlag: shouldRollbackOnReorg ? RollbackOnReorg : NoRollback,
  historyFlag: shouldSaveFullHistory ? FullHistory : MinHistory,
}

let historyConfig = makeHistoryConfig(~shouldRollbackOnReorg={{should_rollback_on_reorg}}, ~shouldSaveFullHistory={{should_save_full_history}})

let shouldRollbackOnReorg = switch historyConfig {
| {rollbackFlag: RollbackOnReorg} => true
| _ => false
}

let shouldSaveHistory = switch historyConfig {
| {rollbackFlag: RollbackOnReorg} | {historyFlag: FullHistory} => true
| _ => false
}

let shouldPruneHistory = switch historyConfig {
| {historyFlag: MinHistory} => true
| _ => false
}

/**
Determines whether to use HypersyncClient Decoder or Viem for parsing events
Default is hypersync client decoder, configurable in config with:
```yaml
event_decoder: "viem" || "hypersync-client"
```
*/
let shouldUseHypersyncClientDecoder =
  Env.Configurable.shouldUseHypersyncClientDecoder->Belt.Option.getWithDefault({{should_use_hypersync_client_decoder}})

let isUnorderedMultichainMode =
  Env.Configurable.isUnorderedMultichainMode->Belt.Option.getWithDefault(
    Env.Configurable.unstable__temp_unordered_head_mode->Belt.Option.getWithDefault({{is_unordered_multichain_mode}}),
  )

let db: Postgres.poolConfig = {
  host: Env.Db.host,
  port: Env.Db.port,
  user: Env.Db.user,
  password: Env.Db.password,
  database: Env.Db.database,
  ssl: Env.Db.ssl,
  // TODO: think how we want to pipe these logs to pino.
  onnotice: Env.userLogLevel == #warn || Env.userLogLevel == #error ? None : Some(() => ()),
}

let getSyncConfig = ({
  initialBlockInterval,
  backoffMultiplicative,
  accelerationAdditive,
  intervalCeiling,
  backoffMillis,
  queryTimeoutMillis,
}) => {
  initialBlockInterval: Env.Configurable.SyncConfig.initialBlockInterval->Belt.Option.getWithDefault(
    initialBlockInterval,
  ),
  // After an RPC error, how much to scale back the number of blocks requested at once
  backoffMultiplicative: Env.Configurable.SyncConfig.backoffMultiplicative->Belt.Option.getWithDefault(
    backoffMultiplicative,
  ),
  // Without RPC errors or timeouts, how much to increase the number of blocks requested by for the next batch
  accelerationAdditive: Env.Configurable.SyncConfig.accelerationAdditive->Belt.Option.getWithDefault(
    accelerationAdditive,
  ),
  // Do not further increase the block interval past this limit
  intervalCeiling: Env.Configurable.SyncConfig.intervalCeiling->Belt.Option.getWithDefault(
    intervalCeiling,
  ),
  // After an error, how long to wait before retrying
  backoffMillis,
  // How long to wait before cancelling an RPC request
  queryTimeoutMillis,
}

let getConfig = (chain: ChainMap.Chain.t) =>
  switch chain {
  {{#each chain_configs as | chain_config |}}
  | Chain_{{chain_config.network_config.id}} => {
      confirmedBlockThreshold: 200, //TODO: This is currently hardcoded, it should be determined per chain
      syncSource: 
      {{#if chain_config.network_config.rpc_config}}
      Rpc({
        provider: Ethers.JsonRpcProvider.makeStatic(
                  ~rpcUrl="{{chain_config.network_config.rpc_config.url}}",
                  ~chainId={{chain_config.network_config.id}}
                  ),

      {{#with chain_config.network_config.rpc_config.unstable__sync_config as | sync_config |}}
        syncConfig: getSyncConfig({
          initialBlockInterval: {{sync_config.initial_block_interval}},
          backoffMultiplicative: {{sync_config.backoff_multiplicative}},
          accelerationAdditive: {{sync_config.acceleration_additive}},
          intervalCeiling: {{sync_config.interval_ceiling}},
          backoffMillis: {{sync_config.backoff_millis}},
          queryTimeoutMillis: {{sync_config.query_timeout_millis}},
        }),
      }),
      {{/with}}
      {{/if}}
      {{#if chain_config.network_config.skar_server_url}}
      HyperSync("{{chain_config.network_config.skar_server_url}}"),
      {{/if}}
      startBlock: {{chain_config.network_config.start_block}},
      endBlock: {{#if chain_config.network_config.end_block}} Some({{chain_config.network_config.end_block}}) {{else}} None {{/if}},
      chain: Chain_{{chain_config.network_config.id}},
      contracts: [
      {{#each chain_config.codegen_contracts as | contract |}}
        {
          name: "{{contract.name.capitalized}}",
          abi: Abis.{{contract.name.uncapitalized}}Abi->Ethers.makeAbi,
          addresses: [
            {{#each contract.addresses as | address |}}
            "{{address}}"->Ethers.getAddressFromStringUnsafe,
            {{/each}}
            ],
            events: [
            {{#each contract.events as | event |}}
            {{event.event_type.full}},
            {{/each}}
            ],
        },
      {{/each}}
      ],
    }
  {{/each}}
  }

let config: chainConfigs = ChainMap.make(getConfig)
