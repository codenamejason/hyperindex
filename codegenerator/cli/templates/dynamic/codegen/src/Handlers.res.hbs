type functionRegister = Loader | Handler

let mapFunctionRegisterName = (functionRegister: functionRegister) => {
  switch functionRegister {
  | Loader => "Loader"
  | Handler => "Handler"
  }
}

// This set makes sure that the warning doesn't print for every event of a type, but rather only prints the first time.
let hasPrintedWarning = Set.make()

let getDefaultLoaderHandler: (
  ~functionRegister: functionRegister,
  ~eventName: string,
  ~event: 'a,
  ~context: 'b,
) => unit = (~functionRegister, ~eventName, ~event as _, ~context as _) => {
  let functionName = mapFunctionRegisterName(functionRegister)

  // Here we use this key to prevent flooding the users terminal with
  let repeatKey = `${eventName}-${functionName}`
  if !(hasPrintedWarning->Set.has(repeatKey)) {
    Logging.warn(
      // TODO: link to our docs.
      `Ignored ${eventName} event, as there is no ${functionName} registered. You need to implement a ${eventName}${functionName} method in your handler file. This will apply to all future ${eventName} events.`,
    )
    let _ = hasPrintedWarning->Set.add(repeatKey)
  }
}

type handlerFunction<'eventArgs, 'context, 'return> = (
  ~event: Types.eventLog<'eventArgs>,
  ~context: 'context,
) => 'return

type handlerSyncAsync<'eventArgs, 'syncContext, 'asyncContext> = SyncAsync.t<
  handlerFunction<'eventArgs, 'syncContext, unit>,
  handlerFunction<'eventArgs, 'asyncContext, promise<unit>>,
>

type loader<'eventArgs, 'loaderContext> = (
  ~event: Types.eventLog<'eventArgs>,
  ~context: 'loaderContext,
) => unit

{{#each contracts as | contract |}}
module {{contract.name.capitalized}}Contract = {
  {{#each contract.events as | event |}}  
  module {{event.name.capitalized}} = {
    open Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event

    type handler = handlerSyncAsync<eventArgs, handlerContextSync, handlerContextAsync>

    %%private(
      let {{event.name.uncapitalized}}Loader: ref<option<loader<eventArgs, loaderContext>>> = ref(None)
      let {{event.name.uncapitalized}}Handler: ref<option<handler>> = ref(None)
    )

    @genType
    let loader = loader => {
      {{event.name.uncapitalized}}Loader := Some(loader)
      }

    @genType
    let handlerSync = handler => {
      {{event.name.uncapitalized}}Handler :=
        Some(Sync(handler))
    }

    @genType
    let handlerAsync = handler => {
      {{event.name.uncapitalized}}Handler :=
        Some(Async(handler))
    }

    let getLoader = () =>
      {{event.name.uncapitalized}}Loader.contents->Belt.Option.getWithDefault(
        getDefaultLoaderHandler(~eventName="{{event.name.capitalized}}", ~functionRegister=Loader)
      )

    
    let getHandler = () =>
      switch {{event.name.uncapitalized}}Handler.contents {
        | Some(handler) => handler        
        | None =>
          Sync(getDefaultLoaderHandler(~eventName="{{event.name.capitalized}}", ~functionRegister=Handler))
     }

    let handlerIsAsync = () => getHandler()->SyncAsync.isAsync
  }
  {{/each}}
}

{{/each}}

