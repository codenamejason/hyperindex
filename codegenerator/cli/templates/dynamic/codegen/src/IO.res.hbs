module InMemoryStore = {
  let entityCurrentCrud = (currentCrud: option<Types.dbOp>, nextCrud: Types.dbOp): Types.dbOp => {
    switch (currentCrud, nextCrud) {
    | (Some(Set), Read)
    | (_, Set) =>
      Set
    | (Some(Read), Read) => Read
    | (Some(Delete), Read)
    | (_, Delete) =>
      Delete
    | (None, _) => nextCrud
    }
  }

  module type StoreItem = {
    type t
    type key
    let hasher: key => string
  }

  //Binding used for deep cloning stores in tests
  @val external structuredClone: 'a => 'a = "structuredClone"

  module MakeStore = (StoreItem: StoreItem) => {
    type value = StoreItem.t
    type key = StoreItem.key
    type hasher = StoreItem.key => string
    type t = {
      dict: Js.Dict.t<Types.inMemoryStoreRow<StoreItem.t>>,
      hasher: hasher,
    }

    let make = (): t => {dict: Js.Dict.empty(), hasher: StoreItem.hasher}

    let set = (self: t, ~key: StoreItem.key, ~dbOp, ~entity: StoreItem.t) =>
      self.dict->Js.Dict.set(key->self.hasher, {entity, dbOp})

    let get = (self: t, key: StoreItem.key) =>
      self.dict->Js.Dict.get(key->self.hasher)->Belt.Option.map(row => row.entity)

    let values = (self: t) => self.dict->Js.Dict.values

    let clone = (self: t) => {
      ...self,
      dict: self.dict->structuredClone,
    }
  }

  module EventSyncState = MakeStore({
    type t = DbFunctions.EventSyncState.eventSyncState
    type key = int
    let hasher = Belt.Int.toString
  })

  type rawEventsKey = {
    chainId: int,
    eventId: string,
  }

  module RawEvents = MakeStore({
    type t = Types.rawEventsEntity
    type key = rawEventsKey
    let hasher = (key: key) =>
      EventUtils.getEventIdKeyString(~chainId=key.chainId, ~eventId=key.eventId)
  })

  type dynamicContractRegistryKey = {
    chainId: int,
    contractAddress: Ethers.ethAddress,
  }

  module DynamicContractRegistry = MakeStore({
    type t = Types.dynamicContractRegistryEntity
    type key = dynamicContractRegistryKey
    let hasher = ({chainId, contractAddress}) =>
      EventUtils.getContractAddressKeyString(~chainId, ~contractAddress)
  })

{{#each entities as | entity |}}

  module {{entity.name.capitalized}} = MakeStore({
    type t = Types.{{entity.name.uncapitalized}}Entity
    type key = string
    let hasher = Obj.magic
  })

{{/each}}


  type t = {
    eventSyncState: EventSyncState.t,
    rawEvents: RawEvents.t,
    dynamicContractRegistry: DynamicContractRegistry.t,
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: {{entity.name.capitalized}}.t,
  {{/each}}
  }

  let make = (): t => {
    eventSyncState: EventSyncState.make(),
    rawEvents: RawEvents.make(),
    dynamicContractRegistry: DynamicContractRegistry.make(),
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: {{entity.name.capitalized}}.make(),
  {{/each}}
  }

  let clone = (self: t) => {
    eventSyncState: self.eventSyncState->EventSyncState.clone,
    rawEvents: self.rawEvents->RawEvents.clone,
    dynamicContractRegistry: self.dynamicContractRegistry->DynamicContractRegistry.clone,
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: self.{{entity.name.uncapitalized}}->{{entity.name.capitalized}}.clone,
  {{/each}}
  }
}

type uniqueEntityReadIds = Js.Dict.t<Types.id>
type allEntityReads = Js.Dict.t<uniqueEntityReadIds>

let loadEntities = async (
  sql,
  ~inMemoryStore: InMemoryStore.t,
  ~entityBatch: array<Types.entityRead>,
) => {
  let loadLayer = ref(false)

  {{#each entities as | entity |}}
  let unique{{entity.name.capitalized}}Dict = Js.Dict.empty()
  {{/each}}

  let populateLoadAsEntityFunctions: ref<array<unit => unit>> = ref([])

  {{#each entities as | entity |}}
  let unique{{entity.name.capitalized}}AsEntityFieldArray: ref<array<string>> = ref([])
  {{/each}}

  @warning("-39")

  let rec{{#each entities as | entity |}}{{#unless @first}}@warning("-27") and {{/unless}} {{entity.name.uncapitalized}}LinkedEntityLoader = (
    entityId: string,
    {{#if entity.relational_params.filtered_not_derived_from.[0]}}{{entity.name.uncapitalized}}Load: Types.{{entity.name.uncapitalized}}LoaderConfig,{{/if}}
  ) => {
    if (!loadLayer.contents) {
      // NOTE: Always set this to true if it is false, I'm sure there are optimizations. Correctness over optimization for now.
      loadLayer := true
    }
    if Js.Dict.get(unique{{entity.name.capitalized}}Dict, entityId)->Belt.Option.isNone {
      let _ = unique{{entity.name.capitalized}}AsEntityFieldArray.contents->Js.Array2.push(entityId)
      let _ = Js.Dict.set(unique{{entity.name.capitalized}}Dict, entityId, entityId)
    }

    {{#each entity.relational_params.filtered_not_derived_from as | relational_param |}}
    //Loader is not used in every generated case
    //Suppressing unused variable warning 27 for these cases
    @warning("-27")
    switch {{entity.name.uncapitalized}}Load.load{{relational_param.relational_key.capitalized}} {
    | Some(load{{relational_param.mapped_entity.capitalized}}) =>
      let _ = populateLoadAsEntityFunctions.contents->Js.Array2.push(() => {
        let _ = inMemoryStore.{{entity.name.uncapitalized}}->InMemoryStore.{{entity.name.capitalized}}.get(entityId)->Belt.Option.map(
          {{entity.name.uncapitalized}}Entity => {
            {{#if (eq relational_param.relationship_type "array")}}
              let _ = {{entity.name.uncapitalized}}Entity.{{relational_param.relational_key.uncapitalized}}->Belt.Array.map(
                    {{relational_param.relational_key.uncapitalized}}Id =>
                {{relational_param.mapped_entity.uncapitalized}}LinkedEntityLoader({{relational_param.relational_key.uncapitalized}}Id, {{#each ../../entities as | internal_entity |}}{{#if (eq internal_entity.name.capitalized relational_param.mapped_entity.capitalized)}}{{#if internal_entity.relational_params.filtered_not_derived_from.[0]}}load{{relational_param.mapped_entity.capitalized}}, {{/if}}{{/if}}{{/each}})
              )
            {{else}}
              {{#if relational_param.is_optional}}
                let _ = {{entity.name.uncapitalized}}Entity.{{relational_param.relational_key.uncapitalized}}->Belt.Option.map(
                  {{relational_param.relational_key.uncapitalized}}Id =>
                    {{relational_param.mapped_entity.uncapitalized}}LinkedEntityLoader({{relational_param.relational_key.uncapitalized}}Id, {{#each ../../entities as | internal_entity |}}{{#if (eq internal_entity.name.capitalized relational_param.mapped_entity.capitalized)}}{{#if internal_entity.relational_params.filtered_not_derived_from.[0]}}load{{relational_param.mapped_entity.capitalized}}, {{/if}}{{/if}}{{/each}})
                )
              {{else}}
                let _ = {{relational_param.mapped_entity.uncapitalized}}LinkedEntityLoader({{entity.name.uncapitalized}}Entity.{{relational_param.relational_key.uncapitalized}}, {{#each ../../entities as | internal_entity |}}{{#if (eq internal_entity.name.capitalized relational_param.mapped_entity.capitalized)}}{{#if internal_entity.relational_params.filtered_not_derived_from.[0]}}load{{relational_param.mapped_entity.capitalized}}, {{/if}}{{/if}}{{/each}})
              {{/if}}
            {{/if}}
          })
      })
    | None => ()
    }
    {{/each}}
    ()
  }{{/each}}

  @warning("+39")

  entityBatch->Belt.Array.forEach(readEntity => {
        switch readEntity {
    {{#each entities as | entity |}}
    | {{entity.name.capitalized}}Read(entityId{{#if entity.relational_params.filtered_not_derived_from.[0]}}, {{entity.name.uncapitalized}}Load{{/if}}) =>
      {{entity.name.uncapitalized}}LinkedEntityLoader(entityId{{#if entity.relational_params.filtered_not_derived_from.[0]}}, {{entity.name.uncapitalized}}Load{{/if}})
    {{/each}}
    }
  })

  while loadLayer.contents {
    loadLayer := false

  {{#each entities as | entity |}}
    if unique{{entity.name.capitalized}}AsEntityFieldArray.contents->Array.length > 0 {
      let {{entity.name.uncapitalized}}FieldEntitiesArray =
        await sql->DbFunctions.{{entity.name.capitalized}}.read{{entity.name.capitalized}}Entities(unique{{entity.name.capitalized}}AsEntityFieldArray.contents)

      {{entity.name.uncapitalized}}FieldEntitiesArray->Belt.Array.forEach(readRow => {
        let {entity} = DbFunctions.{{entity.name.capitalized}}.readRowToReadEntityData(readRow)

        inMemoryStore.{{entity.name.uncapitalized}}->InMemoryStore.{{entity.name.capitalized}}.set(
          ~key=entity.id,
          ~entity,
          ~dbOp=Types.Read,
        )
      })

      unique{{entity.name.capitalized}}AsEntityFieldArray := []
    }
  {{/each}}

  let functionsToExecute = populateLoadAsEntityFunctions.contents

  populateLoadAsEntityFunctions := []

  functionsToExecute->Belt.Array.forEach(func => func())
  }
}

let executeEntityFunction = (
  sql: Postgres.sql,
  ~rows: array<Types.inMemoryStoreRow<'a>>,
  ~dbOp: Types.dbOp,
  ~dbFunction: (Postgres.sql, array<'b>) => promise<unit>,
  ~getInputValFromRow: Types.inMemoryStoreRow<'a> => 'b,
) => {
  let entityIds =
    rows->Belt.Array.keepMap(row => row.dbOp == dbOp ? Some(row->getInputValFromRow) : None)

  if entityIds->Array.length > 0 {
    sql->dbFunction(entityIds)
  } else {
    Promise.resolve()
  }
}

let executeSet = executeEntityFunction(~dbOp=Set)
let executeDelete = executeEntityFunction(~dbOp=Delete)

let executeSetSchemaEntity = (~entityEncoder) =>
  executeSet(
   ~getInputValFromRow=row => {
    row.entity->entityEncoder
  })

let executeBatch = async ( sql, ~inMemoryStore: InMemoryStore.t ) => {
  let setEventSyncState = executeSet(
    ~dbFunction=DbFunctions.EventSyncState.batchSetEventSyncState,
    ~getInputValFromRow=row => row.entity,
    ~rows=inMemoryStore.eventSyncState->InMemoryStore.EventSyncState.values,
  )

  let setRawEvents = executeSet(
    ~dbFunction=DbFunctions.RawEvents.batchSetRawEvents,
    ~getInputValFromRow=row => row.entity,
    ~rows=inMemoryStore.rawEvents->InMemoryStore.RawEvents.values,
  )

  let setDynamicContracts = executeSet(
    ~dbFunction=DbFunctions.DynamicContractRegistry.batchSetDynamicContractRegistry,
    ~rows=inMemoryStore.dynamicContractRegistry->InMemoryStore.DynamicContractRegistry.values,
    ~getInputValFromRow={row => row.entity},
  )

  {{#each entities as | entity |}}
  let delete{{entity.name.capitalized}}s = executeDelete(
    ~dbFunction=DbFunctions.{{entity.name.capitalized}}.batchDelete{{entity.name.capitalized}},
    ~rows=inMemoryStore.{{entity.name.uncapitalized}}->InMemoryStore.{{entity.name.capitalized}}.values,
    ~getInputValFromRow={row => row.entity.id},
  )

  let set{{entity.name.capitalized}}s = executeSetSchemaEntity(
    ~dbFunction=DbFunctions.{{entity.name.capitalized}}.batchSet{{entity.name.capitalized}},
    ~rows=inMemoryStore.{{entity.name.uncapitalized}}->InMemoryStore.{{entity.name.capitalized}}.values,
    ~entityEncoder=Types.{{entity.name.uncapitalized}}Entity_encode,
  )

  {{/each}}

  let res = await sql->Postgres.beginSql((sql)=>{
    [
      setEventSyncState,
      setRawEvents,
      setDynamicContracts,
      {{#each entities as | entity |}}
      delete{{entity.name.capitalized}}s,
      set{{entity.name.capitalized}}s,
      {{/each}}
    ]->Belt.Array.map(dbFunc => sql->dbFunc)
  })

  res
}
