open Belt

module Chain = {
  type t =
  {{#each chain_configs as | chain_config |}}
    | Chain_{{chain_config.network_config.id}}
  {{/each}}

  let toChainId = chain =>
    switch chain {
    {{#each chain_configs as | chain_config |}}
    | Chain_{{chain_config.network_config.id}} => {{chain_config.network_config.id}}
    {{/each}}
    }

  let toString = chain => chain->toChainId->Int.toString

  exception UndefinedChain(int)

  let fromChainId = chainId =>
    switch chainId {
    {{#each chain_configs as | chain_config |}}
    | {{chain_config.network_config.id}} => Ok(Chain_{{chain_config.network_config.id}})
    {{/each}}
    | c => Error(UndefinedChain(c))
    }

  module ChainIdCmp = Belt.Id.MakeComparableU({
    type t = t
    let cmp = (a, b) => Pervasives.compare(a->toChainId, b->toChainId)
  })
}

type t<'a> = Belt.Map.t<Chain.ChainIdCmp.t, 'a, Chain.ChainIdCmp.identity>

let make = (~base, fn: Chain.t => 'a): t<'a> => {
  base->Map.mapWithKey((chain, _) => fn(chain))
}

let fromArray: array<(Chain.t, 'a)> => t<'a> = arr => {
  arr->Map.fromArray(~id=module(Chain.ChainIdCmp))
}

exception UnexpectedChainDoesNoteExist(int)
let get: (t<'a>, Chain.t) => 'a = (self, chain) =>
  //Can safely get exn since all chains must be set
  switch Map.get(self, chain) {
  | Some(v) => v
  | None => UnexpectedChainDoesNoteExist(chain->Chain.toChainId)->raise
  }

let set: (t<'a>, Chain.t, 'a) => t<'a> = (map, chain, v) => Map.set(map, chain, v)
let values: t<'a> => array<'a> = map => Map.valuesToArray(map)
let keys: t<'a> => array<Chain.t> = map => Map.keysToArray(map)
let entries: t<'a> => array<(Chain.t, 'a)> = map => Map.toArray(map)
let map: (t<'a>, 'a => 'b) => t<'b> = (map, fn) => Map.map(map, fn)
let mapWithKey: (t<'a>, (Chain.t, 'a) => 'b) => t<'b> = (map, fn) => Map.mapWithKey(map, fn)
let reduce: (t<'a>, 'b, (Chain.t, 'a, 'b) => 'b) => 'b = (map, acc, fn) => Map.reduce(map, acc, fn)
let size: t<'a> => int = map => Map.size(map)
let update: (t<'a>, Chain.t, 'a => 'a) => t<'a> = (map, chain, updateFn) =>
  Map.update(map, chain, opt => opt->Option.map(updateFn))
