open Belt

/***** TAKE NOTE ******
This is a hack to get genType to work!

In order for genType to produce recursive types, it needs to be at the 
root module of a file. If it's defined in a nested module it does not 
work. So all the MockDb types and internal functions are defined in TestHelpers_MockDb
and only public functions are recreated and exported from this module.

the following module:
```rescript
module MyModule = {
  @genType
  type rec a = {fieldB: b}
  @genType and b = {fieldA: a}
}
```

produces the following in ts:
```ts
// tslint:disable-next-line:interface-over-type-literal
export type MyModule_a = { readonly fieldB: b };

// tslint:disable-next-line:interface-over-type-literal
export type MyModule_b = { readonly fieldA: MyModule_a };
```

fieldB references type b which doesn't exist because it's defined
as MyModule_b
*/

module MockDb = {
  @genType
  let createMockDb = TestHelpers_MockDb.createMockDb
}

@genType
module Addresses = {
  include TestHelpers_MockAddresses
}


module EventFunctions = {
  /**
  The arguements that get passed to a "processEvent" helper function
  */
  //Note these are made into a record to make operate in the same way
  //for Res, JS and TS.
  @genType
  type eventProcessorArgs<'eventArgs> = {
    event: Types.eventLog<'eventArgs>,
    mockDb: TestHelpers_MockDb.t,
    chainId?: int,
  }


  /**
  The default chain ID to use (ethereum mainnet) if a user does not specify int the 
  eventProcessor helper
  */
  let \"DEFAULT_CHAIN_ID" = try {
    ChainMap.Chain.all->Array.getExn(0)->ChainMap.Chain.toChainId
  } catch {
  | _ =>
    Js.Exn.raiseError("No default chain Id found, please add at least 1 chain to your config.yaml.")
  }

  /**
  A function composer to help create individual processEvent functions
  */
  let makeEventProcessor = (
    ~contextCreator: Context.contextCreator<
      'eventArgs,
      'loaderContext,
      'handlerContextSync,
      'handlerContextAsync,
    >,
    ~getLoader: unit => Handlers.loader<_>,
    ~eventWithContextAccessor: (
      Types.eventLog<'eventArgs>,
      Context.genericContextCreatorFunctions<
        'loaderContext,
        'handlerContextSync,
        'handlerContextAsync,
      >,
    ) => Context.eventAndContext,
    ~eventName: Types.eventName,
    ~cb: TestHelpers_MockDb.t => unit,
  }

  /**
  a composable function to make the "storeOperations" record to represent all the mock
  db operations for each entity.
  */
  let makeStoreOperator = (
    store: IO.InMemoryStore.storeState<'entity, 'key>,
    ~get: (IO.InMemoryStore.storeState<'entity, 'key>, 'key) => option<'entity>,
    ~values: IO.InMemoryStore.storeState<'entity, 'key> => array<Types.inMemoryStoreRow<'entity>>,
        ~set: (
      IO.InMemoryStore.storeState<'entity, 'key>,
      ~key: 'key,
      ~entity: Types.entityData<'entity>,
    ) => unit,
    ~getKey: 'entity => 'key,
  ): storeOperations<'entityKey, 'entity> => {
    getAll: () =>
      store
      ->values
      ->Array.keepMap(row =>
        switch row.current {
        | Set(entity, _) => Some(entity)
        | Read(entity) => Some(entity)
        | Delete(_, _) => None
        }
      ),
    get: store->get,
    set: entity =>
      store->set(
        ~key=entity->getKey,
        ~entity=Set(entity, {chainId: -1, blockNumber: -1, logIndex: -1}),
      ),
    delete: key => store.dict->deleteDictKey(key->store.hasher),
  }

  /**
  The internal make function which can be passed an in memory store and
  instantiate a "MockDb". This is useful for cloning or making a MockDb
  out of an existing inMemoryStore
  */
  let makeWithInMemoryStore = (inMemoryStore: IO.InMemoryStore.t) => {
    let dbInternal = ref(inMemoryStore)

    let rawEvents =
      dbInternal.contents.rawEvents->makeStoreOperator(
        ~get=IO.InMemoryStore.RawEvents.get,
        ~values=IO.InMemoryStore.RawEvents.values,
        ~set=IO.InMemoryStore.RawEvents.set,
        ~getKey=({chainId, eventId}) => {chainId, eventId},
      )

    let eventSyncState =
      dbInternal.contents.eventSyncState->makeStoreOperator(
        ~get=IO.InMemoryStore.EventSyncState.get,
        ~values=IO.InMemoryStore.EventSyncState.values,
        ~set=IO.InMemoryStore.EventSyncState.set,
        ~getKey=({chainId}) => chainId,
      )

    let dynamicContractRegistry =
      dbInternal.contents.dynamicContractRegistry->makeStoreOperator(
        ~get=IO.InMemoryStore.DynamicContractRegistry.get,
        ~values=IO.InMemoryStore.DynamicContractRegistry.values,
        ~set=IO.InMemoryStore.DynamicContractRegistry.set,
        ~getKey=({chainId, contractAddress}) => {chainId, contractAddress},
      )

    let entities = {
    {{#each entities as | entity |}}
      {{entity.name.uncapitalized}}: dbInternal.contents.{{entity.name.uncapitalized}}->makeStoreOperator(
        ~get=IO.InMemoryStore.{{entity.name.capitalized}}.get,
        ~values=IO.InMemoryStore.{{entity.name.capitalized}}.values,
        ~set=IO.InMemoryStore.{{entity.name.capitalized}}.set,
        ~getKey=({id}) => id,
      ),
    {{/each}}
    }

    {__dbInternal__: dbInternal, entities, rawEvents, eventSyncState, dynamicContractRegistry}
  }

  /**
  The constructor function for a mockDb. Call it and then set up the inital state by calling
  any of the set functions it provides access to. A mockDb will be passed into a processEvent 
  helper. Note, process event helpers will not mutate the mockDb but return a new mockDb with
  new state so you can compare states before and after.
  */
  //Note: It's called createMockDb over "make" to make it more intuitive in JS and TS
  let createMockDb = () => makeWithInMemoryStore(IO.InMemoryStore.make())

  /**
  Accessor function for getting the internal inMemoryStore in the mockDb
  */
  let getInternalDb = (self: t) => self.__dbInternal__.contents

  /**
  Deep copies the in memory store data and returns a new mockDb with the same
  state and no references to data from the passed in mockDb
  */
  let cloneMockDb = (self: t) => {
    let clonedInternalDb = self->getInternalDb->IO.InMemoryStore.clone
    clonedInternalDb->makeWithInMemoryStore
  }

  /**
  Specifically create an executor for the mockDb
  */
  let makeMockDbEntityExecuter = (~idsToLoad, ~dbReadFn, ~inMemStoreSetFn, ~store, ~getEntiyId) => {
    let dbReadFn = idsArr => idsArr->Belt.Array.keepMap(id => id->dbReadFn)
    IO.makeEntityExecuterComposer(
      ~idsToLoad,
      ~dbReadFn,
      ~inMemStoreSetFn,
      ~store,
      ~getEntiyId,
      ~unit=(),
      ~then=(res, fn) => res->fn,
    )
  }

  /**
  Executes a single load layer using the mockDb functions
  */
  let executeMockDbLoadLayer = (
    mockDb: t,
    ~loadLayer: IO.LoadLayer.t,
    ~inMemoryStore: IO.InMemoryStore.t,
  ) => {
    ({event, mockDb, ?chainId}) => {
      RegisterHandlers.registerAllHandlers()
      //The user can specify a chainId of an event or leave it off
      //and it will default to "DEFAULT_CHAIN_ID"
      let chainId = chainId->Option.getWithDefault(\"DEFAULT_CHAIN_ID")

      //Create an individual logging context for traceability
      let logger = Logging.createChild(
        ~params={
          "Context": `Test Processor for ${eventName
            ->S.serializeToJsonStringWith(. Types.eventNameSchema)
            ->Result.getExn} Event`,
          "Chain ID": chainId,
          "event": event,
        },
      )

      //Deep copy the data in mockDb, mutate the clone and return the clone
      //So no side effects occur here and state can be compared between process
      //steps
      let mockDbClone = mockDb->TestHelpers_MockDb.cloneMockDb

      let asyncGetters: Context.entityGetters = {
      {{#each entities as | entity |}}
        get{{entity.name.capitalized}}: async id => mockDbClone.entities.{{entity.name.uncapitalized}}.get(id)->Belt.Option.mapWithDefault([], entity => [entity]),
      {{/each}}
  /**
  A function composer for simulating the writing of an inMemoryStore to the external db with a mockDb.
  Runs all set and delete operations currently cached in an inMemory store against the mockDb
  */
  let executeRows = (
    mockDb: t,
    ~inMemoryStore: IO.InMemoryStore.t,
    ~getStore: IO.InMemoryStore.t => IO.InMemoryStore.storeState<'entity, 'key>,
    ~getRows: IO.InMemoryStore.storeState<'entity, 'key> => array<Types.inMemoryStoreRow<'entity>>,
    ~getKey: 'entity => 'key,
    ~setFunction: (
      IO.InMemoryStore.storeState<'entity, 'key>,
      ~key: 'key,
      ~entity: Types.entityData<'entity>,
    ) => unit,
  ) => {
    let gottenStore: IO.InMemoryStore.storeState<'entity, 'key> = inMemoryStore->getStore
    let gottenRows: array<Types.inMemoryStoreRow<'entity>> = gottenStore->getRows

    gottenRows->Array.forEach(row => {
      let store = mockDb->getInternalDb->getStore
      let currentRow: Types.entityData<'entity> = row.current
      switch currentRow {
      | Set(entity: 'entity, _) => store->setFunction(~key=getKey(entity), ~entity=currentRow)
      | Delete(deleteKey, _) => store.dict->deleteDictKey(deleteKey->Obj.magic->store.hasher)
      | Read(_) => ()
      }

      //Construct a new instance of an in memory store to run for the given event
      let inMemoryStore = IO.InMemoryStore.make()

      //Construct a context with the inMemory store for the given event to run
      //loaders and handlers
      let context = contextCreator(~event, ~inMemoryStore, ~chainId, ~logger, ~asyncGetters)

      let loaderContext = context.getLoaderContext()

      let loader = getLoader()

      //Run the loader, to get all the read values/contract registrations
      //into the context
      loader({event, context: loaderContext})

      //Get all the entities are requested to be loaded from the mockDB
      let entityBatch = context.getEntitiesToLoad()

      //Load requested entities from the cloned mockDb into the inMemoryStore
      mockDbClone->TestHelpers_MockDb.loadEntitiesToInMemStore(~entityBatch, ~inMemoryStore)

      //Run the event and handler context through the eventRouter
      //With inMemoryStore
      let eventAndContext: Context.eventRouterEventAndContext = {
        chainId,
        event: eventWithContextAccessor(event, context),
      }

      eventAndContext->EventProcessing.eventRouter(
        ~latestProcessedBlocks=EventProcessing.EventsProcessed.makeEmpty(),
        ~inMemoryStore,
        ~cb=res =>
          switch res {
          | Ok(_latestProcessedBlocks) =>
            //Now that the processing is finished. Simulate writing a batch
            //(Although in this case a batch of 1 event only) to the cloned mockDb
            mockDbClone->TestHelpers_MockDb.writeFromMemoryStore(~inMemoryStore)

            //Return the cloned mock db
            cb(mockDbClone)

          | Error(errHandler) =>
            errHandler->ErrorHandling.log
            errHandler->ErrorHandling.raiseExn
          },
      )
    }
  }


  /**Creates a mock event processor, wrapping the callback in a Promise for async use*/
  let makeAsyncEventProcessor = (
    ~contextCreator,
    ~getLoader,
    ~eventWithContextAccessor,
    ~eventName,
    eventProcessorArgs,
  ) => {
    Promise.make((res, _rej) => {
      makeEventProcessor(
        ~contextCreator,
        ~getLoader,
        ~eventWithContextAccessor,
        ~eventName,
        ~cb=mockDb => res(. mockDb),
        eventProcessorArgs,
      )
    })

    // switch row.dbOp {
    // | Set => store->setFunction(~dbOp=Read, ~key=getKey(row.entity), ~entity=row.entity)
    // | Delete => store.dict->deleteDictKey(row.entity->getKey->store.hasher)
    // | Read => ()
    // }
  }

  /**
  Creates a mock event processor, exposing the return of the callback in the return,
  raises an exception if the handler is async
  */
  let makeSyncEventProcessor = (
    ~contextCreator,
    ~getLoader,
    ~eventWithContextAccessor,
    ~eventName,
    eventProcessorArgs,
  ) => {
    //Dangerously set to None, nextMockDb will be set in the callback
    let nextMockDb = ref(None)
    makeEventProcessor(
      ~contextCreator,
      ~getLoader,
      ~eventWithContextAccessor,
      ~eventName,
      ~cb=mockDb => nextMockDb := Some(mockDb),
      eventProcessorArgs,
  let writeFromMemoryStore = (mockDb: t, ~inMemoryStore: IO.InMemoryStore.t) => {
    open IO
    let getRows: IO.InMemoryStore.RawEvents.t => array<
      Types.inMemoryStoreRow<IO.InMemoryStore.RawEvents.value>,
    > = InMemoryStore.RawEvents.values
    let getStore: IO.InMemoryStore.t => IO.InMemoryStore.storeState<'entity, 'key> = inMemStore => {
      inMemStore.rawEvents
    }
    // INTERNAL STORES/TABLES EXECUTION
    mockDb->executeRows(
      ~inMemoryStore,
      ~getRows,
      ~getStore,
      ~setFunction=InMemoryStore.RawEvents.set,
      ~getKey=(entity): IO.InMemoryStore.rawEventsKey => {
        chainId: entity.chainId,
        eventId: entity.eventId,
      },
    )

    //The callback is called synchronously so nextMockDb should be set.
    //In the case it's not set it would mean that the user is using an async handler
    //in which case we want to error and alert the user.
    switch nextMockDb.contents {
    | Some(mockDb) => mockDb
    | None =>
      Js.Exn.raiseError(
        "processEvent failed because handler is not synchronous, please use processEventAsync instead",
      )
    }
  }

  /**
  Optional params for all additional data related to an eventLog
  */
  @genType
  type mockEventData = {
    blockNumber?: int,
    blockTimestamp?: int,
    blockHash?: string,
    chainId?: int,
    srcAddress?: Ethers.ethAddress,
    transactionHash?: string,
    transactionIndex?: int,
    txOrigin?: option<Ethers.ethAddress>,
    logIndex?: int,
  }

  /**
  Applies optional paramters with defaults for all common eventLog field
  */
  let makeEventMocker = (
    ~params: 'eventParams,
    ~mockEventData: option<mockEventData>,
  ): Types.eventLog<'eventParams> => {
    let {
      ?blockNumber,
      ?blockTimestamp,
      ?blockHash,
      ?srcAddress,
      ?chainId,
      ?transactionHash,
      ?transactionIndex,
      ?logIndex,
      ?txOrigin,
    } =
      mockEventData->Belt.Option.getWithDefault({})

    {
      params,
      txOrigin: txOrigin->Belt.Option.flatMap(i => i),
      chainId: chainId->Belt.Option.getWithDefault(1),
      blockNumber: blockNumber->Belt.Option.getWithDefault(0),
      blockTimestamp: blockTimestamp->Belt.Option.getWithDefault(0),
      blockHash: blockHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
      srcAddress: srcAddress->Belt.Option.getWithDefault(Addresses.defaultAddress),
      transactionHash: transactionHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
      transactionIndex: transactionIndex->Belt.Option.getWithDefault(0),
      logIndex: logIndex->Belt.Option.getWithDefault(0),
    }
  }
}

{{#each codegen_contracts as | contract |}}

module {{contract.name.capitalized}} = {
  {{#each contract.codegen_events as | event |}}
  module {{event.name.capitalized}} = {
    @genType
    let processEvent = EventFunctions.makeSyncEventProcessor(
      ~contextCreator=Context.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.contextCreator,
      ~getLoader=Handlers.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}.getLoader,
      ~eventWithContextAccessor=(
        event,
        context,
      ) => Context.{{contract.name.capitalized}}Contract_{{event.name.capitalized}}WithContext(event, context),
      ~eventName=Types.{{event.event_type.full}},
    )

    @genType
    let processEventAsync = EventFunctions.makeAsyncEventProcessor(
      ~contextCreator=Context.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.contextCreator,
      ~getLoader=Handlers.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}.getLoader,
      ~eventWithContextAccessor=(
        event,
        context,
      ) => Context.{{contract.name.capitalized}}Contract_{{event.name.capitalized}}WithContext(event, context),
      ~eventName=Types.{{event.event_type.full}},
    )

    @genType
    type createMockArgs = {
    {{#each event.params as | param |}}
    {{!--
    TODO: handle potential namespace clash where "mockEventData" is
    also the named key of an event argument
    --}}
      {{param.param_name.uncapitalized}}?: {{param.type_rescript}},
    {{/each}}
      mockEventData?: EventFunctions.mockEventData,
    }

    @genType
    let createMockEvent = args => {
      let {
        {{#each event.params as | param |}}
        ?{{param.param_name.uncapitalized}},
        {{/each}}
        ?mockEventData,
/**
All event processor helpers for all contracts
*/
@genType
let eventProcessors = {
{{#each contracts as | contract |}}
  {{contract.name.uncapitalized}}: {{contract.name.uncapitalized}}EventProcessors,
{{/each}}
}

/**
All mock event helpers for all contracts
*/

{{#each contracts as | contract |}}
{{#each contract.events as | event |}}
@genType
type argsFor{{contract.name.capitalized}}{{event.name.capitalized}}Event = {
{{#each event.params as | param |}}
  {{param.key}}?: {{param.type_rescript}},
{{/each}}
}

@genType
let createMock{{contract.name.capitalized}}{{event.name.capitalized}}Event = (
  ~args: argsFor{{contract.name.capitalized}}{{event.name.capitalized}}Event,
): Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.log => {
  let {
      {{#each event.params as | param |}}
      ?{{param.key}}{{#unless @last}},{{/unless}}
      {{/each}}
      } = args

      let params: Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs = 
      {{#if event.params}}
      {
      {{#each event.params as | param |}}
       {{param.param_name.uncapitalized}}: {{param.param_name.uncapitalized}}->Belt.Option.getWithDefault({{param.default_value_rescript}}),
      {{/each}}
      }
      {{else}}
      ()
      {{/if}}



      EventFunctions.makeEventMocker(~params, ~mockEventData)
    }
  }

  {{/each}}
}
{{/each}}
