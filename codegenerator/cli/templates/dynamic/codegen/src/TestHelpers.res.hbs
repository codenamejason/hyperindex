open Belt
RegisterHandlers.registerAllHandlers()

module MockDb = {
  /**
  A raw js binding to allow deleting from a dict. Used in store delete operation
  */
  let deleteDictKey: (Js.Dict.t<'a>, string) => unit = %raw(`
      function(dict, key) {
        delete dict[key]
      }
    `)

  /**
  all the operator functions a user can access on an entity in the mock db
  stores refer to the the module that MakeStore functor outputs in IO.res
  */
  @genType
  type storeOperations<'entityKey, 'entity> = {
    getAll: unit => array<'entity>,
    get: 'entityKey => option<'entity>,
    set: 'entity => unit,
    delete: 'entityKey => unit,
  }

  /**
  User defined entities always have a string for an id which is used as the 
  key for entity stores
  */
  @genType
  type entityStoreOperations<'entity> = storeOperations<string, 'entity>

  /**
  Each user defined entity will be in this record with all the store or "mockdb" operators
  */
  @genType
  type entities = {
    {{#each entities as | entity |}}
      @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: entityStoreOperations<Types.{{entity.name.uncapitalized}}Entity>,
    {{/each}}
    }

  /**
  The mockDb type is simply an InMemoryStore internally. __dbInternal__ holds a reference
  to an inMemoryStore and all the the accessor methods point to the reference of that inMemory
  store
  */
  @genType
  type t = {
    __dbInternal__: ref<IO.InMemoryStore.t>,
    entities: entities,
    rawEvents: storeOperations<IO.InMemoryStore.rawEventsKey, Types.rawEventsEntity>,
    eventSyncState: storeOperations<Types.chainId, DbFunctions.EventSyncState.eventSyncState>,
    dynamicContractRegistry: storeOperations<
      IO.InMemoryStore.dynamicContractRegistryKey,
      Types.dynamicContractRegistryEntity,
    >,
  }

  /**
  a composable function to make the "storeOperations" record to represent all the mock
  db operations for each entity.
  */
  let makeStoreOperator = (
    store: IO.InMemoryStore.storeState<'entity, 'key>,
    ~get: (IO.InMemoryStore.storeState<'entity, 'key>, 'key) => option<'entity>,
    ~values: IO.InMemoryStore.storeState<'entity, 'key> => array<Types.inMemoryStoreRow<'entity>>,
    ~set: (
      IO.InMemoryStore.storeState<'entity, 'key>,
      ~key: 'key,
      ~dbOp: Types.dbOp,
      ~entity: 'entity,
    ) => unit,
    ~getKey: 'entity => 'key,
  ): storeOperations<'entityKey, 'entity> => {
    getAll: () => store->values->Array.map(row => row.entity),
    get: store->get,
    set: entity => store->set(~key=entity->getKey, ~entity, ~dbOp=Set),
    delete: key => store.dict->deleteDictKey(key->store.hasher),
  }

  /**
  The internal make function which can be passed an in memory store and
  instantiate a "MockDb". This is useful for cloning or making a MockDb
  out of an existing inMemoryStore
  */
  let makeWithInMemoryStore = (inMemoryStore: IO.InMemoryStore.t) => {
    let dbInternal = ref(inMemoryStore)

    let rawEvents =
      dbInternal.contents.rawEvents->makeStoreOperator(
        ~get=IO.InMemoryStore.RawEvents.get,
        ~values=IO.InMemoryStore.RawEvents.values,
        ~set=IO.InMemoryStore.RawEvents.set,
        ~getKey=({chainId, eventId}) => {chainId, eventId},
      )

    let eventSyncState =
      dbInternal.contents.eventSyncState->makeStoreOperator(
        ~get=IO.InMemoryStore.EventSyncState.get,
        ~values=IO.InMemoryStore.EventSyncState.values,
        ~set=IO.InMemoryStore.EventSyncState.set,
        ~getKey=({chainId}) => chainId,
      )

    let dynamicContractRegistry =
      dbInternal.contents.dynamicContractRegistry->makeStoreOperator(
        ~get=IO.InMemoryStore.DynamicContractRegistry.get,
        ~values=IO.InMemoryStore.DynamicContractRegistry.values,
        ~set=IO.InMemoryStore.DynamicContractRegistry.set,
        ~getKey=({chainId, contractAddress}) => {chainId, contractAddress},
      )

    let entities = {
    {{#each entities as | entity |}}
      {{entity.name.uncapitalized}}: dbInternal.contents.{{entity.name.uncapitalized}}->makeStoreOperator(
        ~get=IO.InMemoryStore.{{entity.name.capitalized}}.get,
        ~values=IO.InMemoryStore.{{entity.name.capitalized}}.values,
        ~set=IO.InMemoryStore.{{entity.name.capitalized}}.set,
        ~getKey=({id}) => id,
      ),
    {{/each}}
    }

    {__dbInternal__: dbInternal, entities, rawEvents, eventSyncState, dynamicContractRegistry}
  }

  /**
  The constructor function for a mockDb. Call it and then set up the inital state by calling
  any of the set functions it provides access to. A mockDb will be passed into a processEvent 
  helper. Note, process event helpers will not mutate the mockDb but return a new mockDb with
  new state so you can compare states before and after.
  */
  //Note: It's called createMockDb over "make" to make it more intuitive in JS and TS
  @genType 
  let createMockDb = () => makeWithInMemoryStore(IO.InMemoryStore.make())

  /**
  Accessor function for getting the internal inMemoryStore in the mockDb
  */
  let getInternalDb = (self: t) => self.__dbInternal__.contents

  /**
  Deep copies the in memory store data and returns a new mockDb with the same
  state and no references to data from the passed in mockDb
  */
  let cloneMockDb = (self: t) => {
    let clonedInternalDb = self->getInternalDb->IO.InMemoryStore.clone
    clonedInternalDb->makeWithInMemoryStore
  }

  /**
  Specifically create an executor for the mockDb
  */
  let makeMockDbEntityExecuter = (~idsToLoad, ~dbReadFn, ~inMemStoreSetFn, ~store, ~getEntiyId) => {
    let dbReadFn = idsArr => idsArr->Belt.Array.keepMap(id => id->dbReadFn)
    IO.makeEntityExecuterComposer(
      ~idsToLoad,
      ~dbReadFn,
      ~inMemStoreSetFn,
      ~store,
      ~getEntiyId,
      ~unit=(),
      ~then=(res, fn) => res->fn,
    )
  }

  /**
  Executes a single load layer using the mockDb functions
  */
  let executeMockDbLoadLayer = (
    mockDb: t,
    ~loadLayer: IO.LoadLayer.t,
    ~inMemoryStore: IO.InMemoryStore.t,
  ) => {
    let entityExecutors = [
    {{#each entities as | entity |}}
      makeMockDbEntityExecuter(
        ~idsToLoad=loadLayer.{{entity.name.uncapitalized}}IdsToLoad,
        ~dbReadFn=mockDb.entities.{{entity.name.uncapitalized}}.get,
        ~inMemStoreSetFn=IO.InMemoryStore.{{entity.name.capitalized}}.set,
        ~store=inMemoryStore.{{entity.name.uncapitalized}},
        ~getEntiyId=entity => entity.id,
      ),
    {{/each}}
    ]
    let handleResponses = _ => {
      IO.getNextLayer(~loadLayer)
    }

    IO.executeLoadLayerComposer(~entityExecutors, ~handleResponses)
  }

  /**
  Given an isolated inMemoryStore and an array of read entities. This function loads the 
  requested data from the mockDb into the inMemory store. Simulating how loading happens
  from and external db into the inMemoryStore for a batch during event processing
  */
  let loadEntitiesToInMemStore = (mockDb, ~entityBatch, ~inMemoryStore) => {
    let executeLoadLayerFn = mockDb->executeMockDbLoadLayer
    //In an async handler this would be a Promise.then... in this case
    //just need to return the value and pass it into the callback
    let then = (res, fn) => res->fn
    IO.loadEntitiesToInMemStoreComposer(
      ~inMemoryStore,
      ~entityBatch,
      ~executeLoadLayerFn,
      ~then,
      ~unit=(),
    )
  }

  /**
  A function composer for simulating the writing of an inMemoryStore to the external db with a mockDb.
  Runs all set and delete operations currently cached in an inMemory store against the mockDb
  */
  let executeRows = (
    mockDb: t,
    ~inMemoryStore: IO.InMemoryStore.t,
    ~getStore: IO.InMemoryStore.t => IO.InMemoryStore.storeState<'entity, 'key>,
    ~getRows: IO.InMemoryStore.storeState<'entity, 'key> => array<Types.inMemoryStoreRow<'entity>>,
    ~getKey: 'entity => 'key,
    ~setFunction: (
      IO.InMemoryStore.storeState<'entity, 'key>,
      ~key: 'key,
      ~dbOp: Types.dbOp,
      ~entity: 'entity,
    ) => unit,
  ) => {
    inMemoryStore
    ->getStore
    ->getRows
    ->Array.forEach(row => {
      let store = mockDb->getInternalDb->getStore
      switch row.dbOp {
      | Set => store->setFunction(~dbOp=Read, ~key=getKey(row.entity), ~entity=row.entity)
      | Delete => store.dict->deleteDictKey(row.entity->getKey->store.hasher)
      | Read => ()
      }
    })
  }

  /**
  Simulates the writing of processed data in the inMemoryStore to a mockDb. This function
  executes all the rows on each "store" (or pg table) in the inMemoryStore
  */
  let writeFromMemoryStore = (mockDb: t, ~inMemoryStore: IO.InMemoryStore.t) => {
    open IO
    //INTERNAL STORES/TABLES EXECUTION
    mockDb->executeRows(
      ~inMemoryStore,
      ~getRows=InMemoryStore.RawEvents.values,
      ~getStore=inMemStore => {inMemStore.rawEvents},
      ~setFunction=InMemoryStore.RawEvents.set,
      ~getKey=(entity): IO.InMemoryStore.rawEventsKey => {
        chainId: entity.chainId,
        eventId: entity.eventId,
      },
    )

    mockDb->executeRows(
      ~inMemoryStore,
      ~getStore=inMemStore => {inMemStore.eventSyncState},
      ~getRows=InMemoryStore.EventSyncState.values,
      ~setFunction=InMemoryStore.EventSyncState.set,
      ~getKey=entity => entity.chainId,
    )

    mockDb->executeRows(
      ~inMemoryStore,
      ~getRows=InMemoryStore.DynamicContractRegistry.values,
      ~getStore=inMemStore => {inMemStore.dynamicContractRegistry},
      ~setFunction=InMemoryStore.DynamicContractRegistry.set,
      ~getKey=(entity): IO.InMemoryStore.dynamicContractRegistryKey => {
        chainId: entity.chainId,
        contractAddress: entity.contractAddress,
      },
    )

  //ENTITY EXECUTION
  {{#each entities as | entity |}}
    mockDb->executeRows(
      ~inMemoryStore,
      ~getStore=self => {self.{{entity.name.uncapitalized}}},
      ~getRows=IO.InMemoryStore.{{entity.name.capitalized}}.values,
      ~setFunction=IO.InMemoryStore.{{entity.name.capitalized}}.set,
      ~getKey=entity => entity.id,
    )
  {{/each}}
  }
}

/**
The arguements that get passed to a "processEvent" helper function
*/
//Note these are made into a record to make operate in the same way
//for Res, JS and TS.
@genType
type eventProcessorArgs<'eventArgs> = {
  event: Types.eventLog<'eventArgs>,
  mockDb: MockDb.t,
  chainId?: int,
}

/**
An event processor will process an event with a mockDb and return a new mockDb
with the updated state
*/
@genType
type eventProcessor<'eventArgs> = eventProcessorArgs<'eventArgs> => MockDb.t

/**
A container type to give an explicit "processEvent" name to the eventProcessor 
method
*/
@genType
type processEventContainer<'eventArgs> = {processEvent: eventProcessor<'eventArgs>}


/**
The default chain ID to use (ethereum mainnet) if a user does not specify int the 
eventProcessor helper
*/
let \"DEFAULT_CHAIN_ID" = 1

/**
A function composer to help create individual processEvent functions
*/
let makeEventProcessor = (
  ~contextCreator: Context.contextCreator<'eventArgs, 'loaderContext, 'handlerContext>,
  ~getLoader,
  ~eventWithContextAccessor: (
    Types.eventLog<'eventArgs>,
    unit => 'handlerContext,
  ) => Types.eventAndContext,
  ~eventName: Types.eventName,
): processEventContainer<'eventArgs> => {
  let processEvent = ({event, mockDb, ?chainId}) => {
    //The user can specify a chainId of an event or leave it off
    //and it will default to "DEFAULT_CHAIN_ID"
    let chainId = chainId->Option.getWithDefault(\"DEFAULT_CHAIN_ID")

    //Create an individual logging context for traceability 
    let logger = Logging.createChild(
      ~params={
        "Context": `Test Processor for ${eventName
          ->Types.eventName_encode
          ->Js.Json.stringify} Event`,
        "Chain ID": chainId,
        "event": event,
      },
    )

    //Deep copy the data in mockDb, mutate the clone and return the clone
    //So no side effects occur here and state can be compared between process
    //steps
    let mockDbClone = mockDb->MockDb.cloneMockDb

    //Construct a new instance of an in memory store to run for the given event
    let inMemoryStore = IO.InMemoryStore.make()

    //Construct a context with the inMemory store for the given event to run
    //loaders and handlers
    let context = contextCreator(~event, ~inMemoryStore, ~chainId, ~logger)

    let loaderContext = context.getLoaderContext()

    let loader = getLoader()

    //Run the loader, to get all the read values/contract registrations
    //into the context
    loader(~event, ~context=loaderContext)

    //Get all the entities are requested to be loaded from the mockDB
    let entityBatch = context.getEntitiesToLoad()

    //Load requested entities from the cloned mockDb into the inMemoryStore
    mockDbClone->MockDb.loadEntitiesToInMemStore(~entityBatch, ~inMemoryStore)

    //Run the event and handler context through the eventRouter
    //With inMemoryStore
    let handlerContextGetter = context.getHandlerContext
    let eventAndContext: Types.eventRouterEventAndContext = {
      chainId,
      event: eventWithContextAccessor(event, handlerContextGetter),
    }
    eventAndContext->EventProcessing.eventRouter(~inMemoryStore)

    //Now that the processing is finished. Simulate writing a batch
    //(Although in this case a batch of 1 event only) to the cloned mockDb
    mockDbClone->MockDb.writeFromMemoryStore(~inMemoryStore)

    //Return the cloned mock db
    mockDbClone
  }

  //Wrap the processEvent function in the
  //processEventContainer for easy named access
  //to the function
  {processEvent: processEvent}
}
{{#each contracts as | contract |}}

/**
All event processors helpers for contract {{contract.name.capitalized}}
*/
//Note in TS and JS the object will be capitalized. Wheras rescript it is
//uncapitalized
@genType
type {{contract.name.uncapitalized}}EventProcessors = {
{{#each contract.events as | event |}}
  @as("{{event.name.capitalized}}")
  {{event.name.uncapitalized}}: processEventContainer<Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>,
{{/each}}
}

/**
All event processors helpers for contract {{contract.name.capitalized}}
*/
let {{contract.name.uncapitalized}}EventProcessors = {
{{#each contract.events as | event |}}
  {{event.name.uncapitalized}}: makeEventProcessor(
    ~contextCreator=Context.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.contextCreator,
    ~getLoader=Handlers.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}.getLoader,
    ~eventWithContextAccessor=Types.{{contract.name.uncapitalized}}Contract_{{event.name.capitalized}}WithContext,
    ~eventName=Types.{{event.event_type.full}},
  ),
{{/each}}
}
{{/each}}

/**
All event processor helpers for all contracts
*/
@genType
type eventProcessors = {
{{#each contracts as | contract |}}
  @as("{{contract.name.capitalized}}") {{contract.name.uncapitalized}}: {{contract.name.uncapitalized}}EventProcessors,
{{/each}}
}

/**
All event processor helpers for all contracts
*/
@genType
let eventProcessors = {
{{#each contracts as | contract |}}
  {{contract.name.uncapitalized}}: {{contract.name.uncapitalized}}EventProcessors,
{{/each}}
}

/**
All mock event helpers for all contracts
*/

/**
Optional params for all additional data related to an eventLog
*/
@genType
type eventData = {
  blockNumber?: int,
  blockTimestamp?: int,
  blockHash?: string,
  srcAddress?: Ethers.ethAddress,
  transactionHash?: string,
  transactionIndex?: int,
  logIndex?: int,
}

/**
Applies optional paramters with defaults for all common eventLog field
*/
let createMockEventInternal = (
  ~params: 'eventParams,
  ~eventData: option<eventData>,
): Types.eventLog<'eventParams> => {
  let {
    ?blockNumber,
    ?blockTimestamp,
    ?blockHash,
    ?srcAddress,
    ?transactionHash,
    ?transactionIndex,
    ?logIndex,
  } =
    eventData->Belt.Option.getWithDefault({})

  {
    params,
    blockNumber: blockNumber->Belt.Option.getWithDefault(0),
    blockTimestamp: blockTimestamp->Belt.Option.getWithDefault(0),
    blockHash: blockHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
    srcAddress: srcAddress->Belt.Option.getWithDefault(Ethers.Addresses.defaultAddress),
    transactionHash: transactionHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
    transactionIndex: transactionIndex->Belt.Option.getWithDefault(0),
    logIndex: logIndex->Belt.Option.getWithDefault(0),
  }
}

{{#each contracts as | contract |}}
{{#each contract.events as | event |}}
@genType
type argsFor{{contract.name.capitalized}}{{event.name.capitalized}}Event = {
{{#each event.params as | param |}}
{{!--
TODO: handle potential namespace clash where "eventData" is
also the named key of an event argument
--}}
  {{param.key}}?: {{param.type_rescript}},
{{/each}}
  eventData?: eventData,
}

@genType 
let createMock{{contract.name.capitalized}}{{event.name.capitalized}}Event = (
  ~args: argsFor{{contract.name.capitalized}}{{event.name.capitalized}}Event,
): Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.log => {
  let {
    {{#each event.params as | param |}}
    ?{{param.key}},
    {{/each}}
    ?eventData,
  } = args

  let params: Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs = {
  {{#each event.params as | param |}}
   {{param.key}}: {{param.key}}->Belt.Option.getWithDefault({{param.default_value}}),
  {{/each}}
  }

  createMockEventInternal(~params, ~eventData)
}

{{/each}}
{{/each}}
