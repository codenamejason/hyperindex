type contract = {
name: string,
abi: Ethers.abi,
addresses: array<Ethers.ethAddress>,
  events: array<Types.eventName>,
    }

type syncConfig = {
  initialBlockInterval: int,
  backoffMultiplicative: float,
  accelerationAdditive: int,
  intervalCeiling: int,
  backoffMillis: int,
  queryTimeoutMillis: int,
}

type chainConfig = {
  provider: Ethers.JsonRpcProvider.t,
  startBlock: int,
  chainId: int,
  contracts: array<contract>,
  syncConfig: syncConfig,
}

      type chainConfigs = Js.Dict.t<chainConfig>

        // Logging:
        %%private(let envSafe = EnvSafe.make())

        let getLogLevelConfig = (~name, ~default): Pino.logLevel =>
        envSafe->EnvSafe.get(
        ~name,
        ~struct=S.union([
        S.literalVariant(String("trace"), #trace),
        S.literalVariant(String("debug"), #debug),
        S.literalVariant(String("info"), #info),
        S.literalVariant(String("warn"), #warn),
        S.literalVariant(String("error"), #error),
        S.literalVariant(String("fatal"), #fatal),
        // TODO: fix the following 4 custom log levels. For some reason they don't work.
        S.literalVariant(String("udebug"), #udebug),
        S.literalVariant(String("uinfo"), #uinfo),
        S.literalVariant(String("uwarn"), #uwarn),
        S.literalVariant(String("uerror"), #uerror),
        S.literalVariant(String(""), default),
        S.literalVariant(EmptyOption, default),
        ]),
        (),
        )

        let logFilePath =
        envSafe->EnvSafe.get(~name="LOG_FILE", ~struct=S.string(), ~devFallback="logs/envio.log", ())
        let userLogLevel = getLogLevelConfig(~name="LOG_LEVEL", ~default=#info)
        let baseLogLevel = getLogLevelConfig(~name="BASE_LOG_LEVEL", ~default=#trace)
        let defaultFileLogLevel = getLogLevelConfig(~name="FILE_LOG_LEVEL", ~default=#trace)

        type logStrategyType = [#fileOnly | #consoleRaw | #consolePretty | #both]
        let logStrategy = envSafe->EnvSafe.get(
          ~name="LOG_STRATEGY",
          ~struct=S.union([
            S.literalVariant(String("file-only"), #fileOnly),
            S.literalVariant(String("console-raw"), #consoleRaw),
            S.literalVariant(String("console-pretty"), #consolePretty),
            S.literalVariant(String("both-prettyconsole"), #both),
            // Two default values are pretty print to the console only.
            S.literalVariant(String(""), #consolePretty),
            S.literalVariant(EmptyOption, #consolePretty),
          ]),
          (),
        )
        let useEcsFormat =
          envSafe->EnvSafe.get(~name="LOG_ECS_FORMAT", ~struct=S.bool(), ~devFallback=false, ())

        let db: Postgres.poolConfig = {
        host: envSafe->EnvSafe.get(~name="PG_HOST", ~struct=S.string(), ~devFallback="localhost", ()),
        port: envSafe->EnvSafe.get(~name="PG_PORT", ~struct=S.int()->S.Int.port(), ~devFallback=5432, ()),
        user: envSafe->EnvSafe.get(~name="PG_USER", ~struct=S.string(), ~devFallback="postgres", ()),
        password: envSafe->EnvSafe.get(
        ~name="PG_PASSWORD",
        ~struct=S.string(),
        ~devFallback="testing",
        (),
        ),
        database: envSafe->EnvSafe.get(
        ~name="PG_DATABASE",
        ~struct=S.string(),
        ~devFallback="envio-dev",
        (),
        ),
        ssl: envSafe->EnvSafe.get(~name="SSL_MODE", ~struct=S.string(),
        //this is a dev fallback option for local deployments, shouldn't run in the prod env
        //the SSL modes should be provided as string otherwise as 'require' | 'allow' | 'prefer' | 'verify-full'
        ~devFallback=false->Obj.magic, ()),
        // TODO: think how we want to pipe these logs to pino.
        onnotice: userLogLevel == #warn || userLogLevel == #error ? None : Some(() => ()),
        }

let config: chainConfigs = [
  {{#each chain_configs as | chain_config |}}
  (
  "{{chain_config.network_config.id}}",
  {
  provider: Ethers.JsonRpcProvider.makeStatic(~rpcUrl="{{chain_config.network_config.rpc_config.url}}",
  ~chainId={{chain_config.network_config.id}}),
  startBlock: {{chain_config.network_config.start_block}},
  chainId: {{chain_config.network_config.id}},
  syncConfig: {
    initialBlockInterval: EnvUtils.getIntEnvVar(
      ~envSafe,
      "UNSTABLE__SYNC_CONFIG_INITIAL_BLOCK_INTERVAL",
      ~fallback={{chain_config.network_config.rpc_config.unstable__sync_config.initial_block_interval}},
    ),
    // After an RPC error, how much to scale back the number of blocks requested at once
    backoffMultiplicative: EnvUtils.getFloatEnvVar(
      ~envSafe,
      "UNSTABLE__SYNC_CONFIG_BACKOFF_MULTIPLICATIVE",
      ~fallback={{chain_config.network_config.rpc_config.unstable__sync_config.backoff_multiplicative}},
    ),
    // Without RPC errors or timeouts, how much to increase the number of blocks requested by for the next batch
    accelerationAdditive: EnvUtils.getIntEnvVar(
      ~envSafe,
      "UNSTABLE__SYNC_CONFIG_ACCELERATION_ADDITIVE",
      ~fallback={{chain_config.network_config.rpc_config.unstable__sync_config.acceleration_additive}},
    ),
    // Do not further increase the block interval past this limit
    intervalCeiling: EnvUtils.getIntEnvVar(
      ~envSafe,
      "UNSTABLE__SYNC_CONFIG_INTERVAL_CEILING",
      ~fallback={{chain_config.network_config.rpc_config.unstable__sync_config.interval_ceiling}},
    ),
    // After an error, how long to wait before retrying
    backoffMillis: {{chain_config.network_config.rpc_config.unstable__sync_config.backoff_millis}},
    // How long to wait before cancelling an RPC request
    queryTimeoutMillis:{{chain_config.network_config.rpc_config.unstable__sync_config.query_timeout_millis}},
  },
  contracts: [
  {{#each chain_config.contracts as | contract |}}
  {
  name: "{{contract.name.capitalized}}",
  abi: Abis.{{contract.name.uncapitalized}}Abi->Ethers.makeAbi,
  addresses: [
  {{#each contract.addresses as | address |}}
  "{{address}}"->Ethers.getAddressFromStringUnsafe,
  {{/each}}
  ],
  events: [
  {{#each contract.events as | event |}}
  {{contract.name.capitalized}}Contract_{{event.capitalized}}Event,
  {{/each}}
  ],
  },
  {{/each}}
]

        }
        ),
        {{/each}}
        ]->Js.Dict.fromArray

        

// You need to close the envSafe after you're done with it so that it immediately tells you about your misconfigured environment on startup.
envSafe->EnvSafe.close()
