{{#each contracts as | contract |}}
module {{contract.name.capitalized}}Contract = {
{{#each contract.events as | event |}}
  module {{event.name.capitalized}}Event = {
    type context = Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.context

    type contextCreatorFunctions = {
      getLoaderContext: unit => Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.loaderContext,
      getContext: (~eventData: Types.eventData) => Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.context,
      getEntitiesToLoad: unit => array<Types.entityRead>,
      getAddedDynamicContractRegistrations: unit => array<Types.dynamicContractRegistryEntity>,
    }
    let contextCreator: (
      ~chainId: int,
      ~event: Types.eventLog<'a>,
      ~logger: Pino.t,
    ) => contextCreatorFunctions = (~chainId, ~event, ~logger) => {
      let logger =
        logger->Logging.createChildFrom(
          ~logger=_,
          ~params={"userLog": "{{contract.name.capitalized}}.{{event.name.capitalized}}.context"},
        )
      {{#each event.required_entities as | required_entity |}}
      {{#each required_entity.labels as |label| }}
      let optIdOf_{{label}} = ref(None)
      {{/each}}
      {{/each}}

      let entitiesToLoad: array<Types.entityRead> = []

      let addedDynamicContractRegistrations: array<Types.dynamicContractRegistryEntity> = []

      @warning("-16")
      let loaderContext: Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.loaderContext = {
        contractRegistration: {
        {{#each ../../contracts as |contract_inner| }}
          //TODO only add contracts we've registered for the event in the config
          add{{contract_inner.name.capitalized}}: (contractAddress: Ethers.ethAddress) => 
          {
            let eventId = EventUtils.packEventIndex(
              ~blockNumber=event.blockNumber,
              ~logIndex=event.logIndex,
            )
            let dynamicContractRegistration: Types.dynamicContractRegistryEntity = {
              chainId,
              eventId,
              contractAddress,
              contractType: "{{contract_inner.name.capitalized}}",
            }

            addedDynamicContractRegistrations->Js.Array2.push(dynamicContractRegistration)->ignore

            IO.InMemoryStore.DynamicContractRegistry.setDynamicContractRegistry(~entity=dynamicContractRegistration)
          },
        {{/each}}
        },
      {{#each event.required_entities as | required_entity |}}
        {{required_entity.name.uncapitalized}}: {
      {{#each required_entity.labels as |label| }}
          {{label}}Load: (id: Types.id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, ~loaders={}{{/if}}) => {
            optIdOf_{{label}} := Some(id)

            let _ = Js.Array2.push(entitiesToLoad, Types.{{required_entity.name.capitalized}}Read(id{{#if required_entity.entity_fields_of_required_entity.filtered_not_derived_from.[0]}}, loaders{{/if}}))
          },
      {{/each}}
        },
      {{/each}}
      }
      {
        getEntitiesToLoad: () => entitiesToLoad,
        getAddedDynamicContractRegistrations: () => addedDynamicContractRegistrations,
        getLoaderContext: () => loaderContext,
        getContext: (~eventData) => ({
          log: {
            info: (message: string) => logger->Logging.uinfo(message),
            debug: (message: string) => logger->Logging.udebug(message),
            warn: (message: string) => logger->Logging.uwarn(message),
            error: (message: string) => logger->Logging.uerror(message),
            errorWithExn: (exn: option<Js.Exn.t>, message: string) => logger->Logging.uerrorWithExn(exn, message),
          },
          {{#each ../../entities as | entity |}}
            {{entity.name.uncapitalized}}: {
              set: entity => {IO.InMemoryStore.{{entity.name.capitalized}}.set{{entity.name.capitalized}}(~entity = entity, ~dbOp = Types.Set, ~eventData)},
              delete: id => Logging.warn(`[unimplemented delete] can't delete entity({{entity.name.uncapitalized}}) with ID ${id}.`),
              {{#each event.required_entities as | required_entity |}}
                {{#if (eq entity.name.capitalized required_entity.name.capitalized)}}
                  {{#each required_entity.labels as |label| }}
                  {{label}}: () => optIdOf_{{label}}.contents->Belt.Option.flatMap(id => IO.InMemoryStore.{{required_entity.name.capitalized}}.get{{required_entity.name.capitalized}}(~id)),
                  {{/each}}
                {{/if}}
              {{/each}}
              {{#each entity.relational_params.filtered_not_derived_from as | entity_field |}}
              get{{entity_field.relational_key.capitalized}}: {{entity.name.uncapitalized}} => {
                {{#if entity_field.is_array}}
                  let {{entity_field.relational_key.uncapitalized}}Array = {{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}}->Belt.Array.map(entityId => {
                    let optEntity = IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.get{{entity_field.mapped_entity.capitalized}}(~id=entityId)

                    switch optEntity {
                  | Some({{entity_field.relational_key.uncapitalized}}) => {{entity_field.relational_key.uncapitalized}}
                  | None =>
                    Logging.warn(`{{entity.name.capitalized}} {{entity_field.relational_key.uncapitalized}} data not found. Loading associated {{entity_field.mapped_entity.uncapitalized}} from database.
Please consider loading the {{entity_field.mapped_entity.uncapitalized}} in the Update{{entity.name.capitalized}} entity loader to greatly improve sync speed of your application.
`)
            // TODO: this isn't implemented yet. We should fetch a {{entity_field.mapped_entity.uncapitalized}} with this ID from the database.
            "NOT_IMPLEMENTED_YET"->Obj.magic
          }})
          {{entity_field.relational_key.uncapitalized}}Array
                {{else}}
                {{#if entity_field.is_optional}}
                  let opt{{entity_field.relational_key.capitalized}} = {{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}}->Belt.Option.map(entityFieldId => IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.get{{entity_field.mapped_entity.capitalized}}(~id=entityFieldId))
                {{else}}
                  let opt{{entity_field.relational_key.capitalized}} = IO.InMemoryStore.{{entity_field.mapped_entity.capitalized}}.get{{entity_field.mapped_entity.capitalized}}(~id={{entity.name.uncapitalized}}.{{entity_field.relational_key.uncapitalized}})
                {{/if}}
                  switch opt{{entity_field.relational_key.capitalized}} {
                  | Some({{entity_field.relational_key.uncapitalized}}) => {{entity_field.relational_key.uncapitalized}}
                  | None =>
                    Logging.warn(`{{entity.name.capitalized}} {{entity_field.relational_key.uncapitalized}} data not found. Loading associated {{entity_field.mapped_entity.uncapitalized}} from database.
Please consider loading the {{entity_field.mapped_entity.uncapitalized}} in the Update{{entity.name.capitalized}} entity loader to greatly improve sync speed of your application.
`)
            // TODO: this isn't implemented yet. We should fetch a {{entity_field.mapped_entity.uncapitalized}} with this ID from the database.
            "NOT_IMPLEMENTED_YET"->Obj.magic
          }
              {{/if}}
            },
            {{/each}}
            },
          {{/each}}
        })
      }
    }
  }
{{/each}}
}
{{/each}}
