open Types

module EntityIdsMap = {
  type t = Js.Dict.t<Set.t<Types.id>>

  let makeEmptyEntityIdsMap = (): t => {
    Entities.allTables->Belt.Array.map(table => (table.tableName, Set.make()))->Js.Dict.fromArray
  }

  let addId = (entityIdsMap: t, ~entityName: Entities.entityName, ~entityId) => {
    switch entityIdsMap->Js.Dict.get((entityName :> string)) {
    | Some(ids) => ids->Set.add(entityId)->ignore
    | None => () //unexpected
    }
  }

  let hasId = (entityIdsMap: t, ~entityName: Entities.entityName, ~entityId) => {
    switch entityIdsMap->Js.Dict.get((entityName :> string)) {
    | Some(ids) => ids->Set.has(entityId)
    | None => false //unexpected
    }
  }
}

type asyncGetters = {
{{#each entities as | entity |}}
 get{{entity.name.capitalized}}: Types.id => promise<array<Entities.{{entity.name.capitalized}}.t>>,
{{/each}}
}

/**
The context holds all the state for a given events loader and handler.
We should avoid using type parameters per event type so that this can be passed
around with each event without needing to be wrapped in a variant with the given event
*/
type t = {
  logger: Pino.t,
  eventIdentifier: eventIdentifier,
  eventId: Ethers.BigInt.t,
  blockTimestamp: int,
  chain: ChainMap.Chain.t,
  inMemoryStore: IO.InMemoryStore.t,
  entitiesToLoad: array<entityRead>, //TODO, these could be constructed from the entity ids map later
  addedDynamicContractRegistrations: array<Types.dynamicContractRegistryEntity>,
  entityIdsMap: EntityIdsMap.t,
  asyncGetters: asyncGetters,
}

let getUserLogger = ({logger}: t): Logs.userLogger => {
  info: (message: string) => logger->Logging.uinfo(message),
  debug: (message: string) => logger->Logging.udebug(message),
  warn: (message: string) => logger->Logging.uwarn(message),
  error: (message: string) => logger->Logging.uerror(message),
  errorWithExn: (exn: option<Js.Exn.t>, message: string) =>
    logger->Logging.uerrorWithExn(exn, message),
}

let makeEventIdentifier = (event: Types.eventLog<'a>): Types.eventIdentifier => {
  chainId: event.chainId,
  blockTimestamp: event.blockTimestamp,
  blockNumber: event.blockNumber,
  logIndex: event.logIndex,
}

let getEventId = (event: Types.eventLog<'a>) => {
  EventUtils.packEventIndex(~blockNumber=event.blockNumber, ~logIndex=event.logIndex)
}

let make = (~inMemoryStore, ~chain, ~event: Types.eventLog<'eventArgs>, ~logger, ~asyncGetters) => {
  //async getters get injected for dual use with testing framework
  let {blockTimestamp} = event
  let eventIdentifier = event->makeEventIdentifier
  let eventId = event->getEventId

  {
    logger,
    eventIdentifier,
    eventId,
    blockTimestamp,
    chain,
    inMemoryStore,
    entitiesToLoad: [],
    addedDynamicContractRegistrations: [],
    entityIdsMap: EntityIdsMap.makeEmptyEntityIdsMap(),
    asyncGetters,
  }
}

let makeDynamicContractRegisterFn = (
  ~context,
  ~contractName,
  contractAddress: Ethers.ethAddress,
) => {
  let {eventId, blockTimestamp, chain} = context
  let chainId = chain->ChainMap.Chain.toChainId
  let dynamicContractRegistration: Types.dynamicContractRegistryEntity = {
    chainId,
    eventId,
    blockTimestamp,
    contractAddress,
    contractType: contractName,
  }

  context.addedDynamicContractRegistrations->Js.Array2.push(dynamicContractRegistration)->ignore

  context.inMemoryStore.dynamicContractRegistry->IO.InMemoryStore.DynamicContractRegistry.set(
    ~key={chainId, contractAddress},
    ~entity=dynamicContractRegistration,
  )
}

//TODO remove this warning with next load api
@warning("-16")
let getLoaderContext = (context: t): loaderContext => {
  log: context->getUserLogger,
  contractRegistration: {
    //TODO only add contracts we've registered for the event in the config
    {{#each codegen_contracts as |contract| }}
    add{{contract.name.capitalized}}:  makeDynamicContractRegisterFn(~context, ~contractName="{{contract.name.original}}"),
    {{/each}}
  },
  {{#each entities as | entity |}}
  {{entity.name.uncapitalized}}: {
    load: (entityId: Types.id{{#if entity.relational_params.filtered_not_derived_from.[0]}}, ~loaders={}{{/if}}) => 
    {
      context.entityIdsMap->EntityIdsMap.addId(~entityName={{entity.name.capitalized}}, ~entityId)
      let _ = context.entitiesToLoad->Js.Array2.push({{entity.name.capitalized}}Read(entityId{{#if entity.relational_params.filtered_not_derived_from.[0]}}, loaders{{/if}}))
    },
  },
  {{/each}}
}

let makeEntityHandlerContext = (
  ~eventIdentifier,
  ~store, //TODO: store and store functions should be passed in via module
  ~set,
  ~get,
  ~entityIdsMap: EntityIdsMap.t,
  ~entityName: Entities.entityName,
): entityHandlerContext<'entity> => {
  {
    set: entity => {
      store->set(
        ~key=Obj.magic(entity)["id"],
        ~entity=Set(entity)->Types.mkEntityUpdate(~eventIdentifier),
      )
    },
    deleteUnsafe: id => {
      store->set(~key=id, ~entity=Delete(id)->Types.mkEntityUpdate(~eventIdentifier))
    },
    get: (entityId: Types.id) => {
      if entityIdsMap->EntityIdsMap.hasId(~entityName, ~entityId) {
        store->get(entityId)
      } else {
        Logging.warn(
          `The loader for a "${(entityName :> string)}" of entity with id "${entityId}" was not used please add it to your default loader function (ie. place 'context.${(entityName :> string)}.load("${entityId}")' inside your loader) to avoid unexpected behaviour. This is a runtime validation check.`,
        )

        // NOTE: this will still return the value if it exists in the in-memory store (despite the loader not being run).
        store->get(entityId)

        // TODO: add a further step to synchronously try fetch this from the DB if it isn't in the in-memory store - similar to this PR: https://github.com/Float-Capital/indexer/pull/759
      }
    },
  }
}

let makeEntityHandlerContextAsync = (
  type entity,
  ~eventIdentifier,
  ~store: 'store, //TODO: store and store functions should be passed in via module
  ~set,
  ~get,
  ~entityIdsMap: EntityIdsMap.t,
  ~entityMod: module(Entities.Entity with type t = entity),
  ~initValue: (
    ~allowOverWriteEntity: bool=?,
    ~key: string,
    ~entity: option<entity>,
    'store,
  ) => unit,
  ~asyncGetter,
): entityHandlerContextAsync<entity> => {
  let module(EntityMod) = entityMod
  {
    set: entity => {
      store->set(
        ~key=Obj.magic(entity)["id"],
        ~entity=Set(entity)->Types.mkEntityUpdate(~eventIdentifier),
      )
    },
    deleteUnsafe: id => {
      store->set(~key=id, ~entity=Delete(id)->Types.mkEntityUpdate(~eventIdentifier))
    },
    get: async entityId => {
      if entityIdsMap->EntityIdsMap.hasId(~entityName=EntityMod.name, ~entityId) {
        store->get(entityId)
      } else {
        // NOTE: this will still return the value if it exists in the in-memory store (despite the loader not being run).
        switch store->get(entityId) {
        | Some(entity) => Some(entity)
        | None =>
          let entities = await asyncGetter(entityId)

          let optEntity = entities->Belt.Array.get(0)

          store->initValue(~key=entityId, ~entity=optEntity)

          optEntity
        }
      }
    },
  }
}
//handler context must be defined as a getter function so that it can construct the context
//without stale values whenever it is used
let getHandlerContextSync: t => handlerContext = context => {
  let {inMemoryStore, entityIdsMap, eventIdentifier} = context
  {
    log: context->getUserLogger,
    {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: makeEntityHandlerContext(
      ~eventIdentifier,
      ~entityIdsMap,
      ~set=IO.InMemoryStore.{{entity.name.capitalized}}.set,
      ~get=IO.InMemoryStore.{{entity.name.capitalized}}.get,
      ~store=inMemoryStore.{{entity.name.uncapitalized}},
      ~entityName={{entity.name.capitalized}},
    ),
    {{/each}}
  }
}

let getHandlerContextAsync = context => {
  let {inMemoryStore, entityIdsMap, eventIdentifier, asyncGetters} = context
  {
    log: context->getUserLogger,
    {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: makeEntityHandlerContextAsync(
      ~eventIdentifier,
      ~entityIdsMap,
      ~asyncGetter=asyncGetters.get{{entity.name.capitalized}},
      ~set=IO.InMemoryStore.{{entity.name.capitalized}}.set,
      ~get=IO.InMemoryStore.{{entity.name.capitalized}}.get,
      ~store=inMemoryStore.{{entity.name.uncapitalized}},
      ~entityMod=module(Entities.{{entity.name.capitalized}}),
      ~initValue=IO.InMemoryStore.{{entity.name.capitalized}}.initValue,
    ),
    {{/each}}
  }
}

let getAddedDynamicContractRegistrations = (context: t) => context.addedDynamicContractRegistrations
let getEntitiesToLoad = (context: t) => context.entitiesToLoad
