//*************
//***ENTITIES**
//*************
@genType.as("Id")
type id = string

@@warning("-30")
@genType
type rec {{#each entities as | entity |}}{{#unless @first}}
and {{/unless}}{{entity.name.uncapitalized}}LoaderConfig = {{#if entity.relational_params.filtered_not_derived_from.[0]}}{
  {{#each entity.relational_params.filtered_not_derived_from as | relational_param |}}
  load{{relational_param.relational_key.capitalized}}?: {{relational_param.mapped_entity.uncapitalized}}LoaderConfig,{{/each}}
}{{else}}bool{{/if}}{{/each}}
@@warning("+30")

@genType
type entityRead = 
{{#each entities as | entity |}}
| {{entity.name.capitalized}}Read(id{{#if entity.relational_params.filtered_not_derived_from.[0]}}, {{entity.name.uncapitalized}}LoaderConfig{{/if}})
{{/each}}

//Individual entity loader contexts
//Note these will be uniform after v2 api implementation
{{#each entities as | entity |}}
@genType
type {{entity.name.uncapitalized}}EntityLoaderContext = {
  load: (id{{#if entity.relational_params.filtered_not_derived_from.[0]}}, ~loaders: {{entity.name.uncapitalized}}LoaderConfig=?{{/if}}) => unit,
}
{{/each}}

@genType
type contractRegistrations = {
  //TODO only add contracts we've registered for the event in the config
  {{#each codegen_contracts as |contract| }}
  add{{contract.name.capitalized}}: (Ethers.ethAddress) => unit,
  {{/each}}
}

@genType
type loaderContext = {
  log: Logs.userLogger,
  contractRegistration: contractRegistrations,
  {{#each entities as | entity |}}
  @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: {{entity.name.uncapitalized}}EntityLoaderContext,
  {{/each}}
}

type entityHandlerContext<'entity> = {
  get: id => option<'entity>,
  set: 'entity => unit,
  deleteUnsafe: id => unit,
}

type entityHandlerContextAsync<'entity> = {
  get: id => promise<option<'entity>>,
  set: 'entity => unit,
  deleteUnsafe: id => unit,
}

@genType
type handlerContext = {
  log: Logs.userLogger,
  {{#each entities as | entity |}}
  @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: entityHandlerContext<Entities.{{entity.name.capitalized}}.t>,
  {{/each}}
}

@genType
type handlerContextAsync = {
  log: Logs.userLogger,
  {{#each entities as | entity |}}
  @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: entityHandlerContextAsync<Entities.{{entity.name.capitalized}}.t>,
  {{/each}}
}

//Re-exporting types for backwards compatability
{{#each entities as | entity |}}
@genType.as("{{entity.name.original}}Entity")
type {{entity.name.uncapitalized}}Entity = Entities.{{entity.name.capitalized}}.t
{{/each}}

type eventIdentifier = {
  chainId: int,
  blockTimestamp: int,
  blockNumber: int,
  logIndex: int,
}

type entityUpdateAction<'entityType> =
  | Set('entityType)
  | Delete(string)

type entityUpdate<'entityType> = {
  eventIdentifier: eventIdentifier,
  shouldSaveHistory: bool,
  entityUpdateAction: entityUpdateAction<'entityType>,
}

let mkEntityUpdate = (~shouldSaveHistory=true, ~eventIdentifier, entityUpdateAction) => {
  shouldSaveHistory,
  eventIdentifier,
  entityUpdateAction,
}

type entityValueAtStartOfBatch<'entityType> =
  | NotSet // The entity isn't in the DB yet
  | AlreadySet('entityType)

type existingValueInDb<'entityType> =
  | Retrieved(entityValueAtStartOfBatch<'entityType>)
  // NOTE: We use an postgres function solve the issue of this entities previous value not being known.
  | Unknown

type updatedValue<'entityType> = {
  // Initial value within a batch
  initial: existingValueInDb<'entityType>,
  latest: entityUpdate<'entityType>,
  history: array<entityUpdate<'entityType>>,
}
@genType
type inMemoryStoreRowEntity<'entityType> =
  | Updated(updatedValue<'entityType>)
  | InitialReadFromDb(entityValueAtStartOfBatch<'entityType>) // This means there is no change from the db.

//*************
//**CONTRACTS**
//*************

@genType.as("EventLog")
type eventLog<'a> = {
  params: 'a,
  chainId: int,
  txOrigin: option<Ethers.ethAddress>,
  txTo: option<Ethers.ethAddress>,
  blockNumber: int,
  blockTimestamp: int,
  blockHash: string,
  srcAddress: Ethers.ethAddress,
  transactionHash: string,
  transactionIndex: int,
  logIndex: int,
}

@genType
type eventName =
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | @as("{{event.event_type.truncated_for_pg_enum_limit}}") {{event.event_type.full}}
{{/each}}
{{/each}}

let eventNameSchema = {{#if has_multiple_events }}
S.union([
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  S.literal({{event.event_type.full}}),
{{/each}}
{{/each}}
])
{{else}}
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  S.literal({{event.event_type.full}})
{{/each}}
{{/each}}
{{/if}}

let eventNameToString = (eventName: eventName) => switch eventName {
  {{#each codegen_contracts as | contract |}}
  {{#each contract.codegen_events as | event |}}
    | {{event.event_type.full}} => "{{event.name.capitalized}}"
  {{/each}}
  {{/each}}
}

exception UnknownEvent(string, string)
let eventTopicToEventName = (contractName, topic0) =>
  switch (contractName, topic0) {
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | ("{{contract.name.capitalized}}", "{{event.topic0}}") => {{event.event_type.full}}
{{/each}}
{{/each}}
  | (contractName, topic0) => UnknownEvent(contractName, topic0)->raise
  }

{{#each codegen_contracts as | contract |}}
module {{contract.name.capitalized}}Contract = {
{{#each contract.codegen_events as | event |}}
  module {{event.name.capitalized}}Event = {
    let eventName = {{event.event_type.full}}

    @genType
    type eventArgs = 
    {{#if event.params}}
    {
      {{#each event.params as | param |}}
      {{param.param_name.uncapitalized}}: {{param.type_rescript}},
      {{/each}}
    }
    {{else}}
    unit
    {{/if}}

    let eventArgsSchema = 
      {{#if event.params}}
      S.object((. s) => {
      {{#each event.params as | param |}}
        {{param.param_name.uncapitalized}}: s.field("{{param.param_name.uncapitalized}}", {{param.type_rescript_schema}}),
      {{/each}}
      })
      {{else}}
      S.literal(%raw(`null`))->S.variant((. _) => ())
      {{/if}}

    @genType.as("{{contract.name.capitalized}}Contract_{{event.name.capitalized}}_EventLog")
    type log = eventLog<eventArgs>
  }

{{/each}}
}

{{/each}}
type event =
{{#each codegen_contracts as | contract |}}
{{#each contract.codegen_events as | event |}}
  | {{contract.name.capitalized}}Contract_{{event.name.capitalized}}(eventLog<{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs>)
{{/each}}
{{/each}}

@genType
type chainId = int

type eventBatchQueueItem = {
  timestamp: int,
  chain: ChainMap.Chain.t,
  blockNumber: int,
  logIndex: int,
  event: event,
  //Default to false, if an event needs to
  //be reprocessed after it has loaded dynamic contracts
  //This gets set to true and does not try and reload events
  hasRegisteredDynamicContracts?: bool,
}
