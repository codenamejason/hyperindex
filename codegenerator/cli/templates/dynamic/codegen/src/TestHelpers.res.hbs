open Belt
RegisterHandlers.registerAllHandlers()

module MockDb = {
  /**
  A raw js binding to allow deleting from a dict. Used in store delete operation
  */
  let deleteDictKey: (Js.Dict.t<'a>, string) => unit = %raw(`
      function(dict, key) {
        delete dict[key]
      }
    `)

  /**
  The mockDb type is simply an InMemoryStore internally. __dbInternal__ holds a reference
  to an inMemoryStore and all the the accessor methods point to the reference of that inMemory
  store
  */
  @genType
  type rec t = {
    __dbInternal__: IO.InMemoryStore.t,
    entities: entities,
    rawEvents: storeOperations<IO.InMemoryStore.rawEventsKey, Types.rawEventsEntity>,
    eventSyncState: storeOperations<Types.chainId, DbFunctions.EventSyncState.eventSyncState>,
    dynamicContractRegistry: storeOperations<
      IO.InMemoryStore.dynamicContractRegistryKey,
      Types.dynamicContractRegistryEntity,
    >,
  }

  // Each user defined entity will be in this record with all the store or "mockdb" operators
  and entities = {
    {{#each entities as | entity |}}
      @as("{{entity.name.original}}") {{entity.name.uncapitalized}}: entityStoreOperations<Types.{{entity.name.uncapitalized}}Entity>,
    {{/each}}
    }
  // User defined entities always have a string for an id which is used as the
  // key for entity stores
  and entityStoreOperations<'entity> = storeOperations<string, 'entity>
  // all the operator functions a user can access on an entity in the mock db
  // stores refer to the the module that MakeStore functor outputs in IO.res
  and storeOperations<'entityKey, 'entity> = {
    getAll: unit => array<'entity>,
    get: 'entityKey => option<'entity>,
    set: 'entity => t,
    delete: 'entityKey => t,
  }

  module type StoreState = {
    type value
    type key
    let get: (IO.InMemoryStore.storeState<value, key>, key) => option<value>
    let values: IO.InMemoryStore.storeState<value, key> => array<Types.inMemoryStoreRow<value>>
    let set: (
      IO.InMemoryStore.storeState<value, key>,
      ~key: key,
      ~dbOp: Types.dbOp,
      ~entity: value,
    ) => unit
  }

  // /**
  // a composable function to make the "storeOperations" record to represent all the mock
  // db operations for each entity.
  // */
  let makeStoreOperator = (
    type entity key,
    storeStateMod: module(StoreState with type value = entity and type key = key),
    ~inMemoryStore: IO.InMemoryStore.t,
    ~makeMockDb,
    ~getStore: IO.InMemoryStore.t => IO.InMemoryStore.storeState<entity, key>,
    ~getKey: entity => key,
  ): storeOperations<key, entity> => {
    let module(StoreState) = storeStateMod
    let {get, values, set} = module(StoreState)

    let get = inMemoryStore->getStore->get
    let getAll = () => inMemoryStore->getStore->values->Array.map(row => row.entity)

    let set = entity => {
      let cloned = inMemoryStore->IO.InMemoryStore.clone
      cloned->getStore->set(~key=entity->getKey, ~entity, ~dbOp=Set)
      cloned->makeMockDb
    }

    let delete = key => {
      let cloned = inMemoryStore->IO.InMemoryStore.clone
      let store = cloned->getStore
      store.dict->deleteDictKey(key->store.hasher)
      cloned->makeMockDb
    }

    {
      getAll,
      get,
      set,
      delete,
    }
  }

  /**
  The internal make function which can be passed an in memory store and
  instantiate a "MockDb". This is useful for cloning or making a MockDb
  out of an existing inMemoryStore
  */
  let rec makeWithInMemoryStore = (inMemoryStore: IO.InMemoryStore.t) => {
    let rawEvents = module(IO.InMemoryStore.RawEvents)->makeStoreOperator(
        ~inMemoryStore,
        ~makeMockDb=makeWithInMemoryStore,
        ~getStore=db => db.rawEvents,
        ~getKey=({chainId, eventId}) => {
          chainId,
          eventId,
        },
      )

    let eventSyncState = module(IO.InMemoryStore.EventSyncState)->makeStoreOperator(
        ~inMemoryStore,
        ~makeMockDb=makeWithInMemoryStore,
        ~getStore=db => db.eventSyncState,
        ~getKey=({chainId}) => chainId,
      )

    let dynamicContractRegistry = module(IO.InMemoryStore.DynamicContractRegistry)->makeStoreOperator(
        ~inMemoryStore,
        ~getStore=db => db.dynamicContractRegistry,
        ~makeMockDb=makeWithInMemoryStore,
        ~getKey=({chainId, contractAddress}) => {chainId, contractAddress},
      )

    let entities = {
    {{#each entities as | entity |}}
        {{entity.name.uncapitalized}}: {
          module(IO.InMemoryStore.{{entity.name.capitalized}})->makeStoreOperator(
            ~inMemoryStore,
            ~makeMockDb=makeWithInMemoryStore,
            ~getStore=db => db.{{entity.name.uncapitalized}},
            ~getKey=({id}) => id,
          )
        },
    {{/each}}
    }

    {__dbInternal__: inMemoryStore, entities, rawEvents, eventSyncState, dynamicContractRegistry}
  }

  /**
  The constructor function for a mockDb. Call it and then set up the inital state by calling
  any of the set functions it provides access to. A mockDb will be passed into a processEvent 
  helper. Note, process event helpers will not mutate the mockDb but return a new mockDb with
  new state so you can compare states before and after.
  */
  //Note: It's called createMockDb over "make" to make it more intuitive in JS and TS
  @genType 
  let createMockDb = () => makeWithInMemoryStore(IO.InMemoryStore.make())

  /**
  Accessor function for getting the internal inMemoryStore in the mockDb
  */
  let getInternalDb = (self: t) => self.__dbInternal__

  /**
  Deep copies the in memory store data and returns a new mockDb with the same
  state and no references to data from the passed in mockDb
  */
  let cloneMockDb = (self: t) => {
    let clonedInternalDb = self->getInternalDb->IO.InMemoryStore.clone
    clonedInternalDb->makeWithInMemoryStore
  }

  /**
  Specifically create an executor for the mockDb
  */
  let makeMockDbEntityExecuter = (~idsToLoad, ~dbReadFn, ~inMemStoreSetFn, ~store, ~getEntiyId) => {
    let dbReadFn = idsArr => idsArr->Belt.Array.keepMap(id => id->dbReadFn)
    IO.makeEntityExecuterComposer(
      ~idsToLoad,
      ~dbReadFn,
      ~inMemStoreSetFn,
      ~store,
      ~getEntiyId,
      ~unit=(),
      ~then=(res, fn) => res->fn,
    )
  }

  /**
  Executes a single load layer using the mockDb functions
  */
  let executeMockDbLoadLayer = (
    mockDb: t,
    ~loadLayer: IO.LoadLayer.t,
    ~inMemoryStore: IO.InMemoryStore.t,
  ) => {
    let entityExecutors = [
    {{#each entities as | entity |}}
      makeMockDbEntityExecuter(
        ~idsToLoad=loadLayer.{{entity.name.uncapitalized}}IdsToLoad,
        ~dbReadFn=mockDb.entities.{{entity.name.uncapitalized}}.get,
        ~inMemStoreSetFn=IO.InMemoryStore.{{entity.name.capitalized}}.set,
        ~store=inMemoryStore.{{entity.name.uncapitalized}},
        ~getEntiyId=entity => entity.id,
      ),
    {{/each}}
    ]
    let handleResponses = _ => {
      IO.getNextLayer(~loadLayer)
    }

    IO.executeLoadLayerComposer(~entityExecutors, ~handleResponses)
  }

  /**
  Given an isolated inMemoryStore and an array of read entities. This function loads the 
  requested data from the mockDb into the inMemory store. Simulating how loading happens
  from and external db into the inMemoryStore for a batch during event processing
  */
  let loadEntitiesToInMemStore = (mockDb, ~entityBatch, ~inMemoryStore) => {
    let executeLoadLayerFn = mockDb->executeMockDbLoadLayer
    //In an async handler this would be a Promise.then... in this case
    //just need to return the value and pass it into the callback
    let then = (res, fn) => res->fn
    IO.loadEntitiesToInMemStoreComposer(
      ~inMemoryStore,
      ~entityBatch,
      ~executeLoadLayerFn,
      ~then,
      ~unit=(),
    )
  }

  /**
  A function composer for simulating the writing of an inMemoryStore to the external db with a mockDb.
  Runs all set and delete operations currently cached in an inMemory store against the mockDb
  */
  let executeRows = (
    mockDb: t,
    ~inMemoryStore: IO.InMemoryStore.t,
    ~getStore: IO.InMemoryStore.t => IO.InMemoryStore.storeState<'entity, 'key>,
    ~getRows: IO.InMemoryStore.storeState<'entity, 'key> => array<Types.inMemoryStoreRow<'entity>>,
    ~getKey: 'entity => 'key,
    ~setFunction: (
      IO.InMemoryStore.storeState<'entity, 'key>,
      ~key: 'key,
      ~dbOp: Types.dbOp,
      ~entity: 'entity,
    ) => unit,
  ) => {
    inMemoryStore
    ->getStore
    ->getRows
    ->Array.forEach(row => {
      let store = mockDb->getInternalDb->getStore
      switch row.dbOp {
      | Set => store->setFunction(~dbOp=Read, ~key=getKey(row.entity), ~entity=row.entity)
      | Delete => store.dict->deleteDictKey(row.entity->getKey->store.hasher)
      | Read => ()
      }
    })
  }

  /**
  Simulates the writing of processed data in the inMemoryStore to a mockDb. This function
  executes all the rows on each "store" (or pg table) in the inMemoryStore
  */
  let writeFromMemoryStore = (mockDb: t, ~inMemoryStore: IO.InMemoryStore.t) => {
    open IO
    //INTERNAL STORES/TABLES EXECUTION
    mockDb->executeRows(
      ~inMemoryStore,
      ~getRows=InMemoryStore.RawEvents.values,
      ~getStore=inMemStore => {inMemStore.rawEvents},
      ~setFunction=InMemoryStore.RawEvents.set,
      ~getKey=(entity): IO.InMemoryStore.rawEventsKey => {
        chainId: entity.chainId,
        eventId: entity.eventId,
      },
    )

    mockDb->executeRows(
      ~inMemoryStore,
      ~getStore=inMemStore => {inMemStore.eventSyncState},
      ~getRows=InMemoryStore.EventSyncState.values,
      ~setFunction=InMemoryStore.EventSyncState.set,
      ~getKey=entity => entity.chainId,
    )

    mockDb->executeRows(
      ~inMemoryStore,
      ~getRows=InMemoryStore.DynamicContractRegistry.values,
      ~getStore=inMemStore => {inMemStore.dynamicContractRegistry},
      ~setFunction=InMemoryStore.DynamicContractRegistry.set,
      ~getKey=(entity): IO.InMemoryStore.dynamicContractRegistryKey => {
        chainId: entity.chainId,
        contractAddress: entity.contractAddress,
      },
    )

  //ENTITY EXECUTION
  {{#each entities as | entity |}}
    mockDb->executeRows(
      ~inMemoryStore,
      ~getStore=self => {self.{{entity.name.uncapitalized}}},
      ~getRows=IO.InMemoryStore.{{entity.name.capitalized}}.values,
      ~setFunction=IO.InMemoryStore.{{entity.name.capitalized}}.set,
      ~getKey=entity => entity.id,
    )
  {{/each}}
  }
}

module EventFunctions = {
  /**
  The arguements that get passed to a "processEvent" helper function
  */
  //Note these are made into a record to make operate in the same way
  //for Res, JS and TS.
  @genType
  type eventProcessorArgs<'eventArgs> = {
    event: Types.eventLog<'eventArgs>,
    mockDb: MockDb.t,
    chainId?: int,
  }

  /**
  An event processor will process an event with a mockDb and return a new mockDb
  with the updated state
  */
  @genType
  type eventProcessor<'eventArgs> = eventProcessorArgs<'eventArgs> => MockDb.t



  /**
  The default chain ID to use (ethereum mainnet) if a user does not specify int the 
  eventProcessor helper
  */
  let \"DEFAULT_CHAIN_ID" = 1

  /**
  A function composer to help create individual processEvent functions
  */
  let makeEventProcessor = (
    ~contextCreator: Context.contextCreator<'eventArgs, 'loaderContext, 'handlerContext>,
    ~getLoader,
    ~eventWithContextAccessor: (
      Types.eventLog<'eventArgs>,
      unit => 'handlerContext,
    ) => Types.eventAndContext,
    ~eventName: Types.eventName,
  ): eventProcessor<'eventArgs> => {
    ({event, mockDb, ?chainId}) => {
      //The user can specify a chainId of an event or leave it off
      //and it will default to "DEFAULT_CHAIN_ID"
      let chainId = chainId->Option.getWithDefault(\"DEFAULT_CHAIN_ID")

      //Create an individual logging context for traceability 
      let logger = Logging.createChild(
        ~params={
          "Context": `Test Processor for ${eventName
            ->Types.eventName_encode
            ->Js.Json.stringify} Event`,
          "Chain ID": chainId,
          "event": event,
        },
      )

      //Deep copy the data in mockDb, mutate the clone and return the clone
      //So no side effects occur here and state can be compared between process
      //steps
      let mockDbClone = mockDb->MockDb.cloneMockDb

      //Construct a new instance of an in memory store to run for the given event
      let inMemoryStore = IO.InMemoryStore.make()

      //Construct a context with the inMemory store for the given event to run
      //loaders and handlers
      let context = contextCreator(~event, ~inMemoryStore, ~chainId, ~logger)

      let loaderContext = context.getLoaderContext()

      let loader = getLoader()

      //Run the loader, to get all the read values/contract registrations
      //into the context
      loader(~event, ~context=loaderContext)

      //Get all the entities are requested to be loaded from the mockDB
      let entityBatch = context.getEntitiesToLoad()

      //Load requested entities from the cloned mockDb into the inMemoryStore
      mockDbClone->MockDb.loadEntitiesToInMemStore(~entityBatch, ~inMemoryStore)

      //Run the event and handler context through the eventRouter
      //With inMemoryStore
      let handlerContextGetter = context.getHandlerContext
      let eventAndContext: Types.eventRouterEventAndContext = {
        chainId,
        event: eventWithContextAccessor(event, handlerContextGetter),
      }
      eventAndContext->EventProcessing.eventRouter(~inMemoryStore)

      //Now that the processing is finished. Simulate writing a batch
      //(Although in this case a batch of 1 event only) to the cloned mockDb
      mockDbClone->MockDb.writeFromMemoryStore(~inMemoryStore)

      //Return the cloned mock db
      mockDbClone
    }
  }

  /**
  Optional params for all additional data related to an eventLog
  */
  @genType
  type mockEventData = {
    blockNumber?: int,
    blockTimestamp?: int,
    blockHash?: string,
    srcAddress?: Ethers.ethAddress,
    transactionHash?: string,
    transactionIndex?: int,
    logIndex?: int,
  }

  /**
  Applies optional paramters with defaults for all common eventLog field
  */
  let makeEventMocker = (~params: 'eventParams, ~mockEventData: option<mockEventData>): Types.eventLog<
    'eventParams,
  > => {
    let {
      ?blockNumber,
      ?blockTimestamp,
      ?blockHash,
      ?srcAddress,
      ?transactionHash,
      ?transactionIndex,
      ?logIndex,
    } =
      mockEventData->Belt.Option.getWithDefault({})

    {
      params,
      blockNumber: blockNumber->Belt.Option.getWithDefault(0),
      blockTimestamp: blockTimestamp->Belt.Option.getWithDefault(0),
      blockHash: blockHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
      srcAddress: srcAddress->Belt.Option.getWithDefault(Ethers.Addresses.defaultAddress),
      transactionHash: transactionHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
      transactionIndex: transactionIndex->Belt.Option.getWithDefault(0),
      logIndex: logIndex->Belt.Option.getWithDefault(0),
    }
  }
}

{{#each contracts as | contract |}}

module {{contract.name.capitalized}} = {
  {{#each contract.events as | event |}}
  module {{event.name.capitalized}} = {
    @genType
    let processEvent = EventFunctions.makeEventProcessor(
      ~contextCreator=Context.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.contextCreator,
      ~getLoader=Handlers.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}.getLoader,
      ~eventWithContextAccessor=Types.{{contract.name.uncapitalized}}Contract_{{event.name.capitalized}}WithContext,
      ~eventName=Types.{{event.event_type.full}},
    )

    @genType
    type createMockArgs = {
    {{#each event.params as | param |}}
    {{!--
    TODO: handle potential namespace clash where "mockEventData" is
    also the named key of an event argument
    --}}
      {{param.key}}?: {{param.type_rescript}},
    {{/each}}
      mockEventData?: EventFunctions.mockEventData,
    }

    @genType
    let createMockEvent = args => {
      let {
        {{#each event.params as | param |}}
        ?{{param.key}},
        {{/each}}
        ?mockEventData,
      } = args

      let params: Types.{{contract.name.capitalized}}Contract.{{event.name.capitalized}}Event.eventArgs = {
      {{#each event.params as | param |}}
       {{param.key}}: {{param.key}}->Belt.Option.getWithDefault({{param.default_value}}),
      {{/each}}
      }

      EventFunctions.makeEventMocker(~params, ~mockEventData)
    }
  }

  {{/each}}
}
{{/each}}
