/***** TAKE NOTE ******
This is a hack to get genType to work!

In order for genType to produce recursive types, it needs to be at the 
root module of a file. If it's defined in a nested module it does not 
work. So all the MockDb types and internal functions are defined in TestHelpers_MockDb
and only public functions are recreated and exported from this module.

the following module:
```rescript
module MyModule = {
  @genType
  type rec a = {fieldB: b}
  @genType and b = {fieldA: a}
}
```

produces the following in ts:
```ts
// tslint:disable-next-line:interface-over-type-literal
export type MyModule_a = { readonly fieldB: b };

// tslint:disable-next-line:interface-over-type-literal
export type MyModule_b = { readonly fieldA: MyModule_a };
```

fieldB references type b which doesn't exist because it's defined
as MyModule_b
*/

module MockDb = {
  @genType
  let createMockDb = TestHelpers_MockDb.createMockDb
}

@genType
module Addresses = {
  include TestHelpers_MockAddresses
}


module EventFunctions = {
  /**
  The arguements that get passed to a "processEvent" helper function
  */
  //Note these are made into a record to make operate in the same way
  //for Res, JS and TS.
  @genType
  type eventProcessorArgs<'eventArgs> = {
    event: Types.eventLog<'eventArgs>,
    mockDb: TestHelpers_MockDb.t,
    chainId?: int,
  }

  /**
  A function composer to help create individual processEvent functions
  */
  let makeEventProcessor = (
    type eventArgs,
    ~eventMod: module(Types.Event with type eventArgs = eventArgs),
    ~eventAccessor: Types.eventLog<eventArgs> => Types.event,
  ) => {
    async ({event, mockDb, ?chainId}) => {
      let module(Event) = eventMod
      let {eventName} = module(Event)
      let config = RegisterHandlers.registerAllHandlers()

      // The user can specify a chainId of an event or leave it off
      // and it will default to the first chain in the config
      let chain = switch chainId {
        | Some(chainId) => {
          chainId->ChainMap.Chain.fromChainId->Utils.unwrapResultExn
        }
        | None => switch config.defaultChain {
          | Some(chainConfig) => chainConfig.chain
          | None => Js.Exn.raiseError("No default chain Id found, please add at least 1 chain to your config.yaml.")
        }
      }

      //Create an individual logging context for traceability
      let logger = Logging.createChild(
        ~params={
          "Context": `Test Processor for ${(eventName :> string)} Event`,
          "Chain ID": chain->ChainMap.Chain.toChainId,
          "event": event,
        },
      )

      //Deep copy the data in mockDb, mutate the clone and return the clone
      //So no side effects occur here and state can be compared between process
      //steps
      let mockDbClone = mockDb->TestHelpers_MockDb.cloneMockDb

      let asyncGetters: ContextEnv.asyncGetters = {
        {{#each entities as | entity |}}
        get{{entity.name.capitalized}}: async id =>
          mockDbClone.entities.{{entity.name.uncapitalized}}.get(id)->Belt.Option.mapWithDefault([], entity => [entity]),
        {{/each}}
      }

      let registeredEvent = switch RegisteredEvents.global->RegisteredEvents.get(eventName) {
      | Some(l) => l
      | None =>
        Not_found->ErrorHandling.mkLogAndRaise(
          ~logger,
          ~msg=`No registered handler found for ${(eventName :> string)}`,
        )
      }
      //Construct a new instance of an in memory store to run for the given event
      let inMemoryStore = InMemoryStore.make()

      //No need to check contract is registered or return anything.
      //The only purpose is to test the registerContract function and to
      //add the entity to the in memory store for asserting registrations

      switch registeredEvent.contractRegister {
      | Some(contractRegister) =>
        switch contractRegister->EventProcessing.runEventContractRegister(
          ~logger,
          ~event,
          ~eventBatchQueueItem=event
          ->eventAccessor
          ->Types.mkEventBatchQueueItem(
            ~chain,
            ~logIndex=event.logIndex,
            ~timestamp=event.blockTimestamp,
            ~blockNumber=event.blockNumber,
          ),
          ~checkContractIsRegistered=(~chain as _, ~contractAddress as _, ~contractName as _) =>
            false,
          ~dynamicContractRegistrations=None,
          ~eventName,
          ~inMemoryStore,
        ) {
        | Ok(_) => ()
        | Error(e) => e->ErrorHandling.logAndRaise
        }
      | None => () //No need to run contract registration
      }

      let latestProcessedBlocks = EventProcessing.EventsProcessed.makeEmpty(~config)

      switch registeredEvent.loaderHandler {
      | Some(handler) =>
        switch await event->EventProcessing.runEventHandler(
          ~executeLoadLayer=TestHelpers_MockDb.executeMockDbLoadLayer(mockDbClone, ...),
          ~inMemoryStore,
          ~handler,
          ~eventMod,
          ~chain,
          ~logger,
          ~latestProcessedBlocks,
          ~asyncGetters,
        ) {
        | Ok(_) => ()
        | Error(e) => e->ErrorHandling.logAndRaise
        }
      | None => ()//No need to run loaders or handlers
      }

      //In mem store can still contatin raw events and dynamic contracts for the
      //testing framework in cases where either contract register or loaderHandler
      //is None
      mockDbClone->TestHelpers_MockDb.writeFromMemoryStore(~inMemoryStore)
      mockDbClone
    }
  }

  /**
  Optional params for all additional data related to an eventLog
  */
  @genType
  type mockEventData = {
    blockNumber?: int,
    blockTimestamp?: int,
    blockHash?: string,
    chainId?: int,
    srcAddress?: Ethers.ethAddress,
    transactionHash?: string,
    transactionIndex?: int,
    txOrigin?: option<Ethers.ethAddress>,
    txTo?: option<Ethers.ethAddress>,
    logIndex?: int,
  }

  /**
  Applies optional paramters with defaults for all common eventLog field
  */
  let makeEventMocker = (
    ~params: 'eventParams,
    ~mockEventData: option<mockEventData>,
  ): Types.eventLog<'eventParams> => {
    let {
      ?blockNumber,
      ?blockTimestamp,
      ?blockHash,
      ?srcAddress,
      ?chainId,
      ?transactionHash,
      ?transactionIndex,
      ?logIndex,
      ?txOrigin,
      ?txTo,
    } =
      mockEventData->Belt.Option.getWithDefault({})

    {
      params,
      txOrigin: txOrigin->Belt.Option.flatMap(i => i),
      txTo: txTo->Belt.Option.flatMap(i => i),
      chainId: chainId->Belt.Option.getWithDefault(1),
      blockNumber: blockNumber->Belt.Option.getWithDefault(0),
      blockTimestamp: blockTimestamp->Belt.Option.getWithDefault(0),
      blockHash: blockHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
      srcAddress: srcAddress->Belt.Option.getWithDefault(Addresses.defaultAddress),
      transactionHash: transactionHash->Belt.Option.getWithDefault(Ethers.Constants.zeroHash),
      transactionIndex: transactionIndex->Belt.Option.getWithDefault(0),
      logIndex: logIndex->Belt.Option.getWithDefault(0),
    }
  }
}

{{#each codegen_contracts as | contract |}}

module {{contract.name.capitalized}} = {
  {{#each contract.codegen_events as | event |}}
  module {{event.name.capitalized}} = {
    let eventAccessor = event => Types.{{contract.name.capitalized}}_{{event.name.capitalized}}(event)

    @genType
    let processEvent = EventFunctions.makeEventProcessor(
      ~eventAccessor,
      ~eventMod=module(Types.{{contract.name.capitalized}}.{{event.name.capitalized}}),
    )

    @genType
    type createMockArgs = {
      {{#each event.params as | param |}}
      {{!--
      TODO: handle potential namespace clash where "mockEventData" is
      also the named key of an event argument
      --}}
      @as("{{param.js_name}}")
      {{param.res_name}}?: {{param.res_type}},
      {{/each}}
      mockEventData?: EventFunctions.mockEventData,
    }

    @genType
    let createMockEvent = args => {
      let {
        {{#each event.params as | param |}}
        ?{{param.res_name}},
        {{/each}}
        ?mockEventData,
      } = args

      let params: Types.{{contract.name.capitalized}}.{{event.name.capitalized}}.eventArgs = 
      {{#if event.params}}
      {
      {{#each event.params as | param |}}
       {{param.res_name}}: {{param.res_name}}->Belt.Option.getWithDefault({{param.default_value_rescript}}),
      {{/each}}
      }
      {{else}}
      ()
      {{/if}}

      EventFunctions.makeEventMocker(~params, ~mockEventData)
    }
  }

  {{/each}}
}

{{/each}}
