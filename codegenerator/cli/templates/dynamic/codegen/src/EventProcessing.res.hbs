open Belt

module EventsProcessed = {
  type eventsProcessed = {
    numEventsProcessed: int,
    latestProcessedBlock: option<int>,
  }
  type t = ChainMap.t<eventsProcessed>

  let makeEmpty = () => {
    ChainMap.make(_ => {numEventsProcessed: 0, latestProcessedBlock: None})
  }

  let allChainsEventsProcessedToEndblock = (chainFetchers: ChainMap.t<ChainFetcher.t>) => {
    chainFetchers
    ->ChainMap.values
    ->Array.reduce(true, (accum, cf) => cf->ChainFetcher.hasProcessedToEndblock && accum)
  }

  let makeFromChainManager = (cm: ChainManager.t): t => {
    cm.chainFetchers->ChainMap.map(({numEventsProcessed, latestProcessedBlock}) => {
      numEventsProcessed,
      latestProcessedBlock,
    })
  }

  let updateEventsProcessed = (self: t, ~chain, ~blockNumber) => {
    self->ChainMap.update(chain, ({numEventsProcessed}) => {
      numEventsProcessed: numEventsProcessed + 1,
      latestProcessedBlock: Some(blockNumber),
    })
  }
}

type dynamicContractRegistration = {
  registeringEventBlockNumber: int,
  registeringEventLogIndex: int,
  registeringEventChain: ChainMap.Chain.t,
  dynamicContracts: array<TablesStatic.DynamicContractRegistry.t>,
}

type dynamicContractRegistrations = {
  //Its better to apply these in reverse so that we register them with
  //the fetcher from latest to earliest. That way there are less recursions
  registrationsReversed: list<dynamicContractRegistration>,
  unprocessedBatchReversed: list<Types.eventBatchQueueItem>,
}

let addToDynamicContractRegistrations = (
  eventBatchQueueItem: Types.eventBatchQueueItem,
  ~dynamicContracts,
  ~registeringEventBlockNumber,
  ~registeringEventLogIndex,
  ~registrationsReversed,
  ~unprocessedBatchReversed,
) => {
  //If there are any dynamic contract registrations, put this item in the unprocessedBatch flagged
  //with "hasRegisteredDynamicContracts" and return the same list of entitiesToLoad without the
  //current item
  let unprocessedBatchReversed = unprocessedBatchReversed->List.add({
    ...eventBatchQueueItem,
    hasRegisteredDynamicContracts: true,
  })

  let dynamicContractRegistration = {
    dynamicContracts,
    registeringEventBlockNumber,
    registeringEventLogIndex,
    registeringEventChain: eventBatchQueueItem.chain,
  }
  {
    unprocessedBatchReversed,
    registrationsReversed: registrationsReversed->List.add(dynamicContractRegistration),
  }
}

let runEventContractRegister = (
  contractRegister: RegisteredEvents.fnArgs<_> => unit,
  ~event,
  ~eventName,
  ~eventBatchQueueItem: Types.eventBatchQueueItem,
  ~logger,
  ~checkContractIsRegistered,
  ~dynamicContractRegistrations: option<dynamicContractRegistrations>,
  ~inMemoryStore,
) => {
  let {chain} = eventBatchQueueItem
  let contextEnv = ContextEnv.make(~event, ~chain, ~logger, ~eventName)

  switch contractRegister(contextEnv->ContextEnv.getContractRegisterArgs(~inMemoryStore)) {
  | exception exn =>
    exn
    ->ErrorHandling.make(
      ~msg="Event pre loader failed, please fix the error to keep the indexer running smoothly",
      ~logger=contextEnv.logger,
    )
    ->Error
  | () =>
    let dynamicContracts =
      contextEnv
      ->ContextEnv.getAddedDynamicContractRegistrations
      ->Array.keep(({contractAddress, contractType}) =>
        !checkContractIsRegistered(~chain, ~contractAddress, ~contractName=contractType)
      )

    let addToDynamicContractRegistrations =
      eventBatchQueueItem->addToDynamicContractRegistrations(
        ~registeringEventBlockNumber=event.blockNumber,
        ~registeringEventLogIndex=event.logIndex,
      )

    let val = switch (dynamicContracts, dynamicContractRegistrations) {
    | ([], dynamicContractRegistrations) => dynamicContractRegistrations
    | (dynamicContracts, Some({registrationsReversed, unprocessedBatchReversed})) =>
      addToDynamicContractRegistrations(
        ~dynamicContracts,
        ~registrationsReversed,
        ~unprocessedBatchReversed,
      )->Some
    | (dynamicContracts, None) =>
      addToDynamicContractRegistrations(
        ~dynamicContracts,
        ~registrationsReversed=list{},
        ~unprocessedBatchReversed=list{},
      )->Some
    }

    val->Ok
  }
}

let runEventPreloader = async (
  ~contextEnv,
  ~handler: RegisteredEvents.registerArgsWithPreLoader<_>,
  ~loadLayer,
) => {
  let {preLoader} = handler

  switch await preLoader(contextEnv->ContextEnv.getPreLoaderArgs(~loadLayer)) {
  | exception exn =>
    exn
    ->ErrorHandling.make(
      ~msg="Event pre loader failed, please fix the error to keep the indexer running smoothly",
      ~logger=contextEnv.logger,
    )
    ->Error
  | preLoadReturn => preLoadReturn->Ok
  }
}

let addEventToRawEvents = (
  event: Types.eventLog<'a>,
  ~inMemoryStore: InMemoryStore.t,
  ~chainId,
  ~eventArgsSchema: S.t<'a>,
  ~eventName: Enums.EventType.variants,
) => {
  let {
    blockNumber,
    logIndex,
    transactionIndex,
    transactionHash,
    srcAddress,
    blockHash,
    blockTimestamp,
  } = event

  let eventId = EventUtils.packEventIndex(~logIndex, ~blockNumber)
  let rawEvent: TablesStatic.RawEvents.t = {
    chainId,
    eventId: eventId->Ethers.BigInt.toString,
    blockNumber,
    logIndex,
    transactionIndex,
    transactionHash,
    srcAddress,
    blockHash,
    blockTimestamp,
    eventType: eventName,
    params: switch event.params->S.serializeToJsonStringWith(. eventArgsSchema) {
    | Ok(jsonString) => jsonString
    | Error(e) => S.Error.raise(e)
    },
  }

  let eventIdStr = eventId->Ethers.BigInt.toString

  inMemoryStore.rawEvents->InMemoryTable.set({chainId, eventId: eventIdStr}, rawEvent)
}

let updateEventSyncState = (
  event: Types.eventLog<'a>,
  ~chainId,
  ~inMemoryStore: InMemoryStore.t,
) => {
  let {blockNumber, logIndex, transactionIndex, blockTimestamp} = event
  let _ = inMemoryStore.eventSyncState->InMemoryTable.set(
    chainId,
    {
      chainId,
      blockTimestamp,
      blockNumber,
      logIndex,
      transactionIndex,
    },
  )
}

let readEntity = (entityMod, id) => Entities.batchRead(DbFunctions.sql, [id], ~entityMod)
let asyncGetters: ContextEnv.asyncGetters = {
{{#each entities as | entity |}}
 get{{entity.name.capitalized}}: readEntity(module(Entities.{{entity.name.capitalized}})),
{{/each}}
}

let runEventHandler = (
  type eventArgs,
  //Injection params for testing framework
  ~executeLoadLayer=LoadLayer.executeLoadLayer,
  ~asyncGetters=asyncGetters,
  //Required params
  ~eventMod: module(Types.Event with type eventArgs = eventArgs),
  ~handler,
  ~inMemoryStore,
  ~logger,
  ~chain,
  ~latestProcessedBlocks,
  event,
) => {
  open ErrorHandling.ResultPropogateEnv
  runAsyncEnv(async () => {
    let module(Event) = eventMod
    let contextEnv = ContextEnv.make(~event, ~chain, ~logger, ~eventName=Event.eventName)
    let loadLayer = LoadLayer.makeLoadLayer()

    let preLoaderReturnUnawaited = runEventPreloader(~contextEnv, ~handler, ~loadLayer)

    switch await loadLayer->executeLoadLayer(~inMemoryStore) {
    | exception exn =>
      exn
      ->ErrorHandling.make(
        ~msg="Event Handler failed, please fix the error to keep the indexer running smoothly",
        ~logger,
      )
      ->Error
      ->propogate
    | () => ()
    }

    let preLoaderReturn = await preLoaderReturnUnawaited->propogateAsync

    switch await handler.handler(
      contextEnv->ContextEnv.getHandlerArgs(~preLoaderReturn, ~inMemoryStore, ~asyncGetters),
    ) {
    | exception exn =>
      exn
      ->ErrorHandling.make(
        ~msg="Event Handler failed, please fix the error to keep the indexer running smoothly",
        ~logger=contextEnv.logger,
      )
      ->Error
      ->propogate
    | () =>
      let {chainId} = event

      event->updateEventSyncState(~chainId, ~inMemoryStore)
      event->addEventToRawEvents(
        ~inMemoryStore,
        ~chainId,
        ~eventArgsSchema=Event.eventArgsSchema,
        ~eventName=Event.eventName,
      )
      latestProcessedBlocks
      ->EventsProcessed.updateEventsProcessed(~chain, ~blockNumber=event.blockNumber)
      ->Ok
    }
  })
}

let getHandlerRunner = (
  type eventArgs,
  event: Types.eventLog<eventArgs>,
  eventMod: module(Types.Event with type eventArgs = eventArgs),
  ~latestProcessedBlocks,
  ~inMemoryStore,
  ~logger,
  ~chain,
  ~registeredEvents,
) => {
  let module(Event) = eventMod
  switch registeredEvents->RegisteredEvents.get(Event.eventName) {
  | Some(handler) =>
    event->runEventHandler(
      ~handler,
      ~latestProcessedBlocks,
      ~inMemoryStore,
      ~logger,
      ~chain,
      ~eventMod,
    )
  | None => Ok(latestProcessedBlocks)->Promise.resolve
  }
}

let addToUnprocessedBatch = (
  eventBatchQueueItem: Types.eventBatchQueueItem,
  dynamicContractRegistrations,
) => {
  {
    ...dynamicContractRegistrations,
    unprocessedBatchReversed: dynamicContractRegistrations.unprocessedBatchReversed->List.add(
      eventBatchQueueItem,
    ),
  }
}

let rec registerDynamicContracts = (
  ~registeredEvents: RegisteredEvents.t,
  ~checkContractIsRegistered,
  ~logger,
  ~eventsBeforeDynamicRegistrations=[],
  ~dynamicContractRegistrations: option<dynamicContractRegistrations>=None,
  ~inMemoryStore,
  eventBatch: list<Types.eventBatchQueueItem>,
) => {
  switch eventBatch {
  | list{} => (eventsBeforeDynamicRegistrations, dynamicContractRegistrations)->Ok
  | list{eventBatchQueueItem, ...tail} =>
    let dynamicContractRegistrationsResult = if (
      eventBatchQueueItem.hasRegisteredDynamicContracts->Option.getWithDefault(false)
    ) {
      //If an item has already been registered, it would have been
      //put back on the arbitrary events queue and is now being reprocessed
      dynamicContractRegistrations
      ->Option.map(addToUnprocessedBatch(eventBatchQueueItem))
      ->Ok
    } else {
      let runEventContractRegister = (eventName, event) =>
        switch registeredEvents
        ->RegisteredEvents.get(eventName)
        ->Option.flatMap(v => v.contractRegister) {
        | Some(handler) =>
          handler->runEventContractRegister(
            ~event,
            ~logger,
            ~checkContractIsRegistered,
            ~eventBatchQueueItem,
            ~dynamicContractRegistrations,
            ~eventName,
            ~inMemoryStore,
          )
        | None =>
          dynamicContractRegistrations
          ->Option.map(addToUnprocessedBatch(eventBatchQueueItem))
          ->Ok
        }

      open Enums.EventType
      switch eventBatchQueueItem.event {
      {{#each codegen_contracts as | contract |}}
      {{#each contract.codegen_events as | event |}}
      | {{event.event_type.full}}(event) => runEventContractRegister({{event.event_type.full}}, event)
      {{/each}}
      {{/each}}
      }
    }

    switch dynamicContractRegistrationsResult {
    | Ok(dynamicContractRegistrations) =>
      if dynamicContractRegistrations->Option.isNone {
        //Mutate for performance (could otherwise use concat?)
        eventsBeforeDynamicRegistrations->Js.Array2.push(eventBatchQueueItem)->ignore
      }
      tail->registerDynamicContracts(
        ~registeredEvents,
        ~checkContractIsRegistered,
        ~logger,
        ~eventsBeforeDynamicRegistrations,
        ~dynamicContractRegistrations,
        ~inMemoryStore,
      )
    | Error(e) => Error(e)
    }
  }
}

let runPreloaders = (
  eventBatch: array<Types.eventBatchQueueItem>,
  ~registeredEvents: RegisteredEvents.t,
  ~inMemoryStore,
  ~logger,
) => {
  open ErrorHandling.ResultPropogateEnv
  runAsyncEnv(async () => {
    let loadLayer = LoadLayer.makeLoadLayer()

    let preLoaderReturnsUnawaited = eventBatch->Array.keepMap(({chain, event}) => {
      let preLoad = (event, eventName) =>
        registeredEvents
        ->RegisteredEvents.get(eventName)
        ->Option.map(
          handler => {
            let contextEnv = ContextEnv.make(~chain, ~eventName, ~event, ~logger)
            runEventPreloader(~contextEnv, ~handler, ~loadLayer)
          },
        )

      switch event {
      {{#each codegen_contracts as | contract |}}
      {{#each contract.codegen_events as | event |}}
      | {{event.event_type.full}}(event) => event->preLoad({{event.event_type.full}})
      {{/each}}
      {{/each}}
      }
    })

    switch await loadLayer->LoadLayer.executeLoadLayer(~inMemoryStore) {
    | exception exn =>
      exn
      ->ErrorHandling.make(~msg="Load layer failed during execution", ~logger)
      ->Error
      ->propogate
    | () => ()
    }

    let preLoaderReturns = await preLoaderReturnsUnawaited->Promise.all
    //We don't actually need these returns here but errors will be propogated
    //here
    let _unusedReturns = preLoaderReturns->Utils.mapArrayOfResults->propogate
    Ok()
  })
}

let runHandlers = (
  eventBatch: array<Types.eventBatchQueueItem>,
  ~registeredEvents,
  ~inMemoryStore,
  ~latestProcessedBlocks,
  ~logger,
) => {
  open ErrorHandling.ResultPropogateEnv
  let latestProcessedBlocks = ref(latestProcessedBlocks)
  runAsyncEnv(async () => {
    for i in 0 to eventBatch->Array.length - 1 {
      let {event, chain} = eventBatch[i]->Option.getUnsafe

      let runHandler = getHandlerRunner(
        ~inMemoryStore,
        ~logger,
        ~chain,
        ~latestProcessedBlocks=latestProcessedBlocks.contents,
        ~registeredEvents,
      )

      latestProcessedBlocks :=
        switch event {
        {{#each codegen_contracts as | contract |}}
        {{#each contract.codegen_events as | event |}}
        | {{event.event_type.full}}(event) =>
          await event
          ->runHandler(module(Types.{{contract.name.capitalized}}.{{event.name.capitalized}}))
          ->propogateAsync
        {{/each}}
        {{/each}}
        }
    }
    Ok(latestProcessedBlocks.contents)
  })
}

let registerProcessEventBatchMetrics = (
  ~logger,
  ~batchSize,
  ~loadDuration,
  ~handlerDuration,
  ~dbWriteDuration,
) => {
  logger->Logging.childTrace({
    "message": "Finished processing batch",
    "batch_size": batchSize,
    "loader_time_elapsed": loadDuration,
    "handlers_time_elapsed": handlerDuration,
    "write_time_elapsed": dbWriteDuration,
  })

  Prometheus.incrementLoadEntityDurationCounter(~duration=loadDuration)
  Prometheus.incrementEventRouterDurationCounter(~duration=handlerDuration)
  Prometheus.incrementExecuteBatchDurationCounter(~duration=dbWriteDuration)
  Prometheus.incrementEventsProcessedCounter(~number=batchSize)
}

type batchProcessed = {
  latestProcessedBlocks: EventsProcessed.t,
  dynamicContractRegistrations: option<dynamicContractRegistrations>,
}
let processEventBatch = (
  ~eventBatch: list<Types.eventBatchQueueItem>,
  ~inMemoryStore: InMemoryStore.t,
  ~latestProcessedBlocks: EventsProcessed.t,
  ~checkContractIsRegistered,
  ~registeredEvents: RegisteredEvents.t,
) => {
  let logger = Logging.createChild(
    ~params={
      "context": "batch",
      "batch-size": eventBatch->List.length,
      "first-event-timestamp": eventBatch->List.head->Option.map(v => v.timestamp),
    },
  )

  let timeRef = Hrtime.makeTimer()

  open ErrorHandling.ResultPropogateEnv
  runAsyncEnv(async () => {
    //Register all the dynamic contracts in this batch,
    //only continue processing events before the first dynamic contract registration
    let (
      eventsBeforeDynamicRegistrations: array<Types.eventBatchQueueItem>,
      dynamicContractRegistrations,
    ) =
      eventBatch
      ->registerDynamicContracts(
        ~registeredEvents,
        ~checkContractIsRegistered,
        ~logger,
        ~inMemoryStore,
      )
      ->propogate

    await eventsBeforeDynamicRegistrations
    ->runPreloaders(~registeredEvents, ~inMemoryStore, ~logger)
    ->propogateAsync

    let elapsedAfterLoad = timeRef->Hrtime.timeSince->Hrtime.toMillis->Hrtime.intFromMillis

    let latestProcessedBlocks =
      await eventsBeforeDynamicRegistrations
      ->runHandlers(~registeredEvents, ~inMemoryStore, ~latestProcessedBlocks, ~logger)
      ->propogateAsync

    let elapsedTimeAfterProcess = timeRef->Hrtime.timeSince->Hrtime.toMillis->Hrtime.intFromMillis

    switch await DbFunctions.sql->IO.executeBatch(~inMemoryStore) {
    | exception exn =>
      exn->ErrorHandling.make(~msg="Failed writing batch to database", ~logger)->Error->propogate
    | () => ()
    }

    let elapsedTimeAfterDbWrite = timeRef->Hrtime.timeSince->Hrtime.toMillis->Hrtime.intFromMillis
    registerProcessEventBatchMetrics(
      ~logger,
      ~batchSize=eventsBeforeDynamicRegistrations->Array.length,
      ~loadDuration=elapsedAfterLoad,
      ~handlerDuration=elapsedTimeAfterProcess - elapsedAfterLoad,
      ~dbWriteDuration=elapsedTimeAfterDbWrite - elapsedTimeAfterProcess,
    )

    Ok({latestProcessedBlocks, dynamicContractRegistrations})
  })
}
