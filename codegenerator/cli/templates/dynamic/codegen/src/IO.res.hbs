module InMemoryStore = {
  let entityCurrentCrud = (currentCrud: option<Types.dbOp>, nextCrud: Types.dbOp): Types.dbOp => {
    switch (currentCrud, nextCrud) {
    | (Some(Set), Read)
    | (_, Set) =>
      Set
    | (Some(Read), Read) => Read
    | (Some(Delete), Read)
    | (_, Delete) =>
      Delete
    | (None, _) => nextCrud
    }
  }

  type stringHasher<'val> = 'val => string
  type storeState<'entity, 'entityKey> = {
    dict: Js.Dict.t<Types.inMemoryStoreRow<'entity>>,
    hasher: stringHasher<'entityKey>,
  }

  module type StoreItem = {
    type t
    type key
    let hasher: stringHasher<key>
  }

  //Binding used for deep cloning stores in tests
  @val external structuredClone: 'a => 'a = "structuredClone"

  module MakeStore = (StoreItem: StoreItem) => {
    type value = StoreItem.t
    type key = StoreItem.key
    type t = storeState<value, key>

    let make = (): t => {dict: Js.Dict.empty(), hasher: StoreItem.hasher}

    let set = (self: t, ~key: StoreItem.key, ~dbOp, ~entity: StoreItem.t) =>
      self.dict->Js.Dict.set(key->self.hasher, {entity, dbOp})

    let get = (self: t, key: StoreItem.key) =>
      self.dict->Js.Dict.get(key->self.hasher)->Belt.Option.map(row => row.entity)

    let values = (self: t) => self.dict->Js.Dict.values

    let clone = (self: t) => {
      ...self,
      dict: self.dict->structuredClone,
    }
  }

  module EventSyncState = MakeStore({
    type t = DbFunctions.EventSyncState.eventSyncState
    type key = int
    let hasher = Belt.Int.toString
  })

  type rawEventsKey = {
    chainId: int,
    eventId: string,
  }

  module RawEvents = MakeStore({
    type t = Types.rawEventsEntity
    type key = rawEventsKey
    let hasher = (key: key) =>
      EventUtils.getEventIdKeyString(~chainId=key.chainId, ~eventId=key.eventId)
  })

  type dynamicContractRegistryKey = {
    chainId: int,
    contractAddress: Ethers.ethAddress,
  }

  module DynamicContractRegistry = MakeStore({
    type t = Types.dynamicContractRegistryEntity
    type key = dynamicContractRegistryKey
    let hasher = ({chainId, contractAddress}) =>
      EventUtils.getContractAddressKeyString(~chainId, ~contractAddress)
  })

{{#each entities as | entity |}}

  module {{entity.name.capitalized}} = MakeStore({
    type t = Types.{{entity.name.uncapitalized}}Entity
    type key = string
    let hasher = Obj.magic
  })

{{/each}}


  type t = {
    eventSyncState: EventSyncState.t,
    rawEvents: RawEvents.t,
    dynamicContractRegistry: DynamicContractRegistry.t,
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: {{entity.name.capitalized}}.t,
  {{/each}}
  }

  let make = (): t => {
    eventSyncState: EventSyncState.make(),
    rawEvents: RawEvents.make(),
    dynamicContractRegistry: DynamicContractRegistry.make(),
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: {{entity.name.capitalized}}.make(),
  {{/each}}
  }

  let clone = (self: t) => {
    eventSyncState: self.eventSyncState->EventSyncState.clone,
    rawEvents: self.rawEvents->RawEvents.clone,
    dynamicContractRegistry: self.dynamicContractRegistry->DynamicContractRegistry.clone,
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}: self.{{entity.name.uncapitalized}}->{{entity.name.capitalized}}.clone,
  {{/each}}
  }
}


module LoadLayer = {
  type idsToLoad = Utils.UniqueArray.t<Types.id>
  type rec dataLoadedActionsGetters = array<dataLoadedActionsGetter>
  and dataLoadedActionsGetter = unit => array<t => t>
  and t = {
    dataLoadedActionsGetters: dataLoadedActionsGetters,
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}IdsToLoad: idsToLoad,
  {{/each}}
  }

  let emptyLoadLayer = () => {
  {{#each entities as | entity |}}
    {{entity.name.uncapitalized}}IdsToLoad: Utils.UniqueArray.empty(),
  {{/each}}
    dataLoadedActionsGetters: [],
  }

  let extendIdsToLoad = (idsToLoad: idsToLoad, entityId: Types.id): idsToLoad =>
    idsToLoad->Utils.UniqueArray.extend(entityId, entityId)

  let extendDataLoadedActionsGetters = (
    dataLoadedActionsGetters: dataLoadedActionsGetters,
    newDataLoadedActionsGetters: dataLoadedActionsGetters,
  ): dataLoadedActionsGetters =>
    dataLoadedActionsGetters->Belt.Array.concat(newDataLoadedActionsGetters)
}

let rec{{#each entities as | entity |}}{{#unless @first}}@warning("-27") and {{/unless}} {{entity.name.uncapitalized}}LinkedEntityLoader = (
  loadLayer: LoadLayer.t,
  ~entityId: string,
  ~inMemoryStore: InMemoryStore.t,
  ~{{entity.name.uncapitalized}}LoaderConfig: Types.{{entity.name.uncapitalized}}LoaderConfig,
): LoadLayer.t => {
  {{#if entity.relational_params.filtered_not_derived_from.[0]}}
  let dataLoadedActionsGetters = [
  {{#each entity.relational_params.filtered_not_derived_from as | relational_param |}}
    {{entity.name.uncapitalized}}LoaderConfig.load{{relational_param.relational_key.capitalized}}->Belt.Option.map({{relational_param.mapped_entity.uncapitalized}}LoaderConfig => {
      () =>
      inMemoryStore.{{entity.name.uncapitalized}}
      ->InMemoryStore.{{entity.name.capitalized}}.get(entityId)
      ->Belt.Option.mapWithDefault([],entity => {

        let getLoader = 
              (entityId) => 
                {{relational_param.mapped_entity.uncapitalized}}LinkedEntityLoader(
                    ~{{relational_param.mapped_entity.uncapitalized}}LoaderConfig,
                    ~entityId,
                    ~inMemoryStore
                  )
    {{#if (eq relational_param.relationship_type "array")}}
        entity.{{relational_param.relational_key.uncapitalized}}->Belt.Array.map(entityId => entityId->getLoader)
    {{else}}
      {{#if relational_param.is_optional}}
        entity.{{relational_param.relational_key.uncapitalized}}->Belt.Option.mapWithDefault([], entityId => [entityId->getLoader])
      {{else}}
        [entity.{{relational_param.relational_key.uncapitalized}}->getLoader]
      {{/if}}
    {{/if}}
      })
    }),
  {{/each}}
    ]->Belt.Array.keepMap(v => v)

  {
    ...loadLayer,
    {{entity.name.uncapitalized}}IdsToLoad: loadLayer.{{entity.name.uncapitalized}}IdsToLoad->LoadLayer.extendIdsToLoad(entityId),
    dataLoadedActionsGetters: loadLayer.dataLoadedActionsGetters->LoadLayer.extendDataLoadedActionsGetters(
      dataLoadedActionsGetters,
    ),
  }
  {{else}}
  //No side dataLoadedActionsGetters need to happen on the in memory
  //since there are no relational non-derivedfrom params
  let _ = inMemoryStore //ignore inMemoryStore and stop warning
  //In this case the "{{entity.name.uncapitalized}}LoaderConfig" type is a boolean.
  if !{{entity.name.uncapitalized}}LoaderConfig {
    //If {{entity.name.uncapitalized}}LoaderConfig is false, don't load the entity
    //simply return the current load layer
    loadLayer
  } else {
    //If {{entity.name.uncapitalized}}LoaderConfig is true, 
    //extend the entity ids to load field
    //There can be no dataLoadedActionsGetters to add since this type does not contain
    //any non derived from relational params
    {
      ...loadLayer,
      {{entity.name.uncapitalized}}IdsToLoad: loadLayer.{{entity.name.uncapitalized}}IdsToLoad->LoadLayer.extendIdsToLoad(entityId),
    }
  }
  {{/if}}
}
{{/each}}

let getLoadLayer = (~entityBatch: array<Types.entityRead>, ~inMemoryStore) => {
  entityBatch->Belt.Array.reduce(LoadLayer.emptyLoadLayer(), (loadLayer, readEntity) => {
    switch readEntity {
    {{#each entities as | entity |}}
    | {{entity.name.capitalized}}Read(entityId{{#if entity.relational_params.filtered_not_derived_from.[0]}}, {{entity.name.uncapitalized}}LoaderConfig{{/if}}) =>
      loadLayer->{{entity.name.uncapitalized}}LinkedEntityLoader(~entityId, ~inMemoryStore, ~{{entity.name.uncapitalized}}LoaderConfig{{#unless entity.relational_params.filtered_not_derived_from.[0]}}=true{{/unless}})
    {{/each}}
    }
  })
}

type nextLayer = NextLayer(LoadLayer.t) | LastLayer

let executeLoadLayer = async (
  ~sql,
  ~loadLayer: LoadLayer.t,
  ~inMemoryStore: InMemoryStore.t,
): nextLayer => {
  //Load in entities
  {{#each entities as | entity |}}
  switch loadLayer.{{entity.name.uncapitalized}}IdsToLoad->Utils.UniqueArray.values {
  | [] => () //Check if there are values so we don't create an unnecessary empty query
  | idsToLoad => {
      let entities = await sql->DbFunctions.{{entity.name.capitalized}}.readEntities(idsToLoad)
      entities->Belt.Array.forEach(entity => {
        inMemoryStore.{{entity.name.uncapitalized}}->InMemoryStore.{{entity.name.capitalized}}.set(~key=entity.id, ~entity, ~dbOp=Types.Read)
      })
    }
  }
  {{/each}}

  //Run data loaded actions
  switch loadLayer.dataLoadedActionsGetters {
  | [] => LastLayer
  | dataLoadedActionsGetters =>
    dataLoadedActionsGetters
    ->Belt.Array.reduce(LoadLayer.emptyLoadLayer(), (loadLayer, getLoadedActions) => {
      //call getLoadedActions returns array of of actions to run against the load layer
      getLoadedActions()->Belt.Array.reduce(loadLayer, (loadLayer, action) => {
        action(loadLayer)
      })
    })
    ->NextLayer
  }
}

let rec executeNestedLoadLayers = async (~loadLayer, ~sql, ~inMemoryStore) => {
  switch await executeLoadLayer(~inMemoryStore, ~loadLayer, ~sql) {
  | LastLayer => ()
  | NextLayer(loadLayer) => await executeNestedLoadLayers(~loadLayer, ~sql, ~inMemoryStore)
  }
}

let loadEntitiesToInMemStore = async (sql, ~entityBatch, ~inMemoryStore) => {
  let loadLayer = getLoadLayer(~inMemoryStore, ~entityBatch)
  await executeNestedLoadLayers(~inMemoryStore, ~sql, ~loadLayer)
}

let executeEntityFunction = (
  sql: Postgres.sql,
  ~rows: array<Types.inMemoryStoreRow<'a>>,
  ~dbOp: Types.dbOp,
  ~dbFunction: (Postgres.sql, array<'b>) => promise<unit>,
  ~getInputValFromRow: Types.inMemoryStoreRow<'a> => 'b,
) => {
  let entityIds =
    rows->Belt.Array.keepMap(row => row.dbOp == dbOp ? Some(row->getInputValFromRow) : None)

  if entityIds->Array.length > 0 {
    sql->dbFunction(entityIds)
  } else {
    Promise.resolve()
  }
}

let executeSet = executeEntityFunction(~dbOp=Set)
let executeDelete = executeEntityFunction(~dbOp=Delete)

let executeSetSchemaEntity = (~entityEncoder) =>
  executeSet(
   ~getInputValFromRow=row => {
    row.entity->entityEncoder
  })

let executeBatch = async ( sql, ~inMemoryStore: InMemoryStore.t ) => {
  let setEventSyncState = executeSet(
    ~dbFunction=DbFunctions.EventSyncState.batchSet,
    ~getInputValFromRow=row => row.entity,
    ~rows=inMemoryStore.eventSyncState->InMemoryStore.EventSyncState.values,
  )

  let setRawEvents = executeSet(
    ~dbFunction=DbFunctions.RawEvents.batchSet,
    ~getInputValFromRow=row => row.entity,
    ~rows=inMemoryStore.rawEvents->InMemoryStore.RawEvents.values,
  )

  let setDynamicContracts = executeSet(
    ~dbFunction=DbFunctions.DynamicContractRegistry.batchSet,
    ~rows=inMemoryStore.dynamicContractRegistry->InMemoryStore.DynamicContractRegistry.values,
    ~getInputValFromRow={row => row.entity},
  )

  {{#each entities as | entity |}}
  let delete{{entity.name.capitalized}}s = executeDelete(
    ~dbFunction=DbFunctions.{{entity.name.capitalized}}.batchDelete,
    ~rows=inMemoryStore.{{entity.name.uncapitalized}}->InMemoryStore.{{entity.name.capitalized}}.values,
    ~getInputValFromRow={row => row.entity.id},
  )

  let set{{entity.name.capitalized}}s = executeSetSchemaEntity(
    ~dbFunction=DbFunctions.{{entity.name.capitalized}}.batchSet,
    ~rows=inMemoryStore.{{entity.name.uncapitalized}}->InMemoryStore.{{entity.name.capitalized}}.values,
    ~entityEncoder=Types.{{entity.name.uncapitalized}}Entity_encode,
  )

  {{/each}}

  let res = await sql->Postgres.beginSql((sql)=>{
    [
      setEventSyncState,
      setRawEvents,
      setDynamicContracts,
      {{#each entities as | entity |}}
      delete{{entity.name.capitalized}}s,
      set{{entity.name.capitalized}}s,
      {{/each}}
    ]->Belt.Array.map(dbFunc => sql->dbFunc)
  })

  res
}
