enum AccountType {
  ADMIN
  USER
}

type User {
  id: ID!
  address: Bytes!
  gravatar: Gravatar
  updatesCountOnUserForTesting: Int!
  tokens: [Token!]! @derivedFrom(field: "owner")
  accountType: AccountType!
}

enum GravatarSize {
  SMALL
  MEDIUM
  LARGE
}

type Gravatar {
  id: ID!
  owner: User!
  displayName: String!
  imageUrl: String!
  updatesCount: BigInt!
  size: GravatarSize!
}

type PostgresNumericPrecisionEntityTester {
  id: ID!
  exampleBigInt: BigInt @precision(digits: 76)
  exampleBigIntRequired: BigInt! @precision(digits: 77)
  exampleBigIntArray: [BigInt!] @precision(digits: 78)
  exampleBigIntArrayRequired: [BigInt!]! @precision(digits: 79)
  exampleBigDecimal: BigDecimal @numeric(precision: 80, scale: 5)
  exampleBigDecimalRequired: BigDecimal! @numeric(precision: 81, scale: 5)
  exampleBigDecimalArray: [BigDecimal!] @numeric(precision: 82, scale: 5)
  exampleBigDecimalArrayRequired: [BigDecimal!]! @numeric(precision: 83, scale: 5)
  exampleBigDecimalOtherOrder: BigDecimal! @numeric(scale: 6, precision: 84)
}

type NftCollection {
  id: ID!
  contractAddress: Bytes!
  name: String!
  symbol: String!
  maxSupply: BigInt!
  currentSupply: Int!
  tokens: [Token!]! @derivedFrom(field: "collection")
}

type Token
  @index(fields: ["db_write_timestamp"])
  @index(fields: ["id", "tokenId"])
  @index(fields: ["tokenId", "collection"]) {
  id: ID!
  tokenId: BigInt! @index
  collection: NftCollection! @index
  owner: User!
}

type EntityWithBigDecimal {
  id: ID!
  bigDecimal: BigDecimal!
}

type EntityWithTimestamp {
  id: ID!
  timestamp: Timestamp!
}

type A {
  id: ID!
  b: B! @index
  optionalStringToTestLinkedEntities: String
}
type B {
  id: ID!
  a: [A!]! @derivedFrom(field: "b")
  c: C
}
type C {
  id: ID!
  a: A!
  stringThatIsMirroredToA: String!
  d: [D!]! @derivedFrom(field: "c")
}
type D {
  id: ID!
  c: ID! @index
}
