exception UndefinedEvent(string)
let selectEventMod = (eventName: string, contractName: string): module(Types.Event) => {
  switch (eventName, contractName) {
    {{#each codegen_contracts as |contract|}}
    {{#each contract.codegen_events as |event|}}
    | ("{{event.name.capitalized}}", "{{contract.name.capitalized}}") => module(Types.{{contract.name.capitalized}}.{{event.name.capitalized}})
    {{/each}}
    {{/each}}
    | _ => UndefinedEvent(eventName)->raise
  }
}

{{#each codegen_contracts as |contract|}}
module {{contract.name.capitalized}} = {
{{#each contract.codegen_events as |event|}}
  module {{event.name.capitalized}} = {
    let convertViemDecodedEvent: Viem.decodedEvent<'a> => Viem.decodedEvent<
      Types.{{contract.name.capitalized}}.{{event.name.capitalized}}.eventArgs,
    > = Utils.magic

    {{#unless event.params}}
    @warning("-27")
    {{/unless}}
    let convertLogViem = (
      decodedEvent: Viem.decodedEvent<Types.{{contract.name.capitalized}}.{{event.name.capitalized}}.eventArgs>,
      ~log: Ethers.log,
      ~blockTimestamp: int,
      ~chainId: int,
      ~txOrigin: option<Ethers.ethAddress>,
      ~txTo: option<Ethers.ethAddress>,
    ) => {
      let params: Types.{{contract.name.capitalized}}.{{event.name.capitalized}}.eventArgs = 
      {{#if event.params}}
      {
        {{#each event.params as | param |}}
        {{param.res_name}}: decodedEvent.args.{{param.res_name}},
        {{/each}}
      }
      {{else}}
      ()
      {{/if}}

      let eventLog: Types.eventLog<Types.{{contract.name.capitalized}}.{{event.name.capitalized}}.eventArgs> = {
        params,
        chainId,
        txOrigin,
        txTo,
        blockNumber: log.blockNumber,
        blockTimestamp,
        blockHash: log.blockHash,
        srcAddress: log.address,
        transactionHash: log.transactionHash,
        transactionIndex: log.transactionIndex,
        logIndex: log.logIndex,
      }

      Types.{{contract.name.capitalized}}_{{event.name.capitalized}}(eventLog)
    }

    let convertDecodedEventParams = ( 
    {{!-- Add underscore if there are no params, to avoid compiler warning of unused argument --}}
      {{#unless event.params[0]}}_{{/unless}}decodedEvent: HyperSyncClient.Decoder.decodedEvent,
    ): Types.{{contract.name.capitalized}}.{{event.name.capitalized}}.eventArgs => {
      {{#if event.params[0]}}{{!--Only create this body if there are params.  Otherwise its always unit--}}
      {
        {{#each event.indexed_params as | param index |}}
        {{param.res_name}}: decodedEvent.indexed->Js.Array2.unsafe_get({{index}})->HyperSyncClient.Decoder.toUnderlying->Utils.magic,
        {{/each}}
        {{#each event.body_params as | param index |}}
        {{param.res_name}}: decodedEvent.body->Js.Array2.unsafe_get({{index}})->HyperSyncClient.Decoder.toUnderlying->Utils.magic,
        {{/each}}
      }
      {{else}}
      ()
      {{/if}}
    }
  }
{{/each}}
}

{{/each}}

exception ParseError(Ethers.Interface.parseLogError)
exception UnregisteredContract(Ethers.ethAddress)

let makeEventLog = (
  params: 'args,
  ~log: Ethers.log,
  ~blockTimestamp: int,
  ~chainId: int,
  ~txOrigin: option<Ethers.ethAddress>,
  ~txTo: option<Ethers.ethAddress>,
): Types.eventLog<'args> => {
  chainId,
  params,
  txOrigin,
  txTo,
  blockNumber: log.blockNumber,
  blockTimestamp,
  blockHash: log.blockHash,
  srcAddress: log.address,
  transactionHash: log.transactionHash,
  transactionIndex: log.transactionIndex,
  logIndex: log.logIndex,
}

let convertDecodedEvent = (
  event: HyperSyncClient.Decoder.decodedEvent,
  ~contractInterfaceManager,
  ~log: Ethers.log,
  ~blockTimestamp,
  ~chainId,
  ~txOrigin: option<Ethers.ethAddress>,
  ~txTo: option<Ethers.ethAddress>,
): result<(Types.event, module(Types.Event)), _> => {
  switch contractInterfaceManager->ContractInterfaceManager.getContractNameFromAddress(
    ~contractAddress=log.address,
  ) {
  | None => Error(UnregisteredContract(log.address))
  | Some(contractName) =>
    let eventMod = Types.eventTopicToEventMod(contractName, log.topics[0])
    let module(Event) = eventMod
    let event = switch Event.eventName {
      {{#each codegen_contracts as |contract|}}
      {{#each contract.codegen_events as |event|}}
        | {{event.event_type.full}} =>
            event
            ->{{contract.name.capitalized}}.{{event.name.capitalized}}.convertDecodedEventParams
            ->makeEventLog(~log, ~blockTimestamp, ~chainId, ~txOrigin, ~txTo)
            ->Types.{{contract.name.capitalized}}_{{event.name.capitalized}}
      {{/each}}
     {{/each}}
    }
    Ok((event, eventMod))
  }
}

let parseEvent = (~log, ~blockTimestamp, ~contractInterfaceManager, ~chainId, ~txOrigin, ~txTo): Belt.Result.t<
  (Types.event, module(Types.Event)),
  _,
> => {
  let decodedEventResult = contractInterfaceManager->ContractInterfaceManager.parseLogViem(~log)
  switch decodedEventResult {
  | Error(e) =>
    switch e {
    | ParseError(parseError) => ParseError(parseError)
    | UndefinedInterface(contractAddress) => UnregisteredContract(contractAddress)
    }->Error

  | Ok(decodedEvent) =>
    switch contractInterfaceManager->ContractInterfaceManager.getContractNameFromAddress(
      ~contractAddress=log.address,
    ) {
    | None => Error(UnregisteredContract(log.address))
    | Some(contractName) =>
      let eventMod = selectEventMod(decodedEvent.eventName, contractName)
      let module(Event) = eventMod
      let event = switch Event.eventName {
      {{#each codegen_contracts as |contract|}}
      {{#each contract.codegen_events as |event|}}
        | {{event.event_type.full}} =>
          decodedEvent
          ->{{contract.name.capitalized}}.{{event.name.capitalized}}.convertViemDecodedEvent
          ->{{contract.name.capitalized}}.{{event.name.capitalized}}.convertLogViem(~log, ~blockTimestamp, ~chainId, ~txOrigin, ~txTo)
      {{/each}}
      {{/each}}
      }
      Ok(event, eventMod)
    }
  }
}

let decodeRawEventWith = (
  type eventArgs,
  rawEvent: TablesStatic.RawEvents.t,
  ~eventMod: module(Types.Event),
  ~eventAccessor: Types.eventLog<eventArgs> => Types.event,
  ~chain,
  ~txOrigin: option<Ethers.ethAddress>,
  ~txTo: option<Ethers.ethAddress>,
): result<Types.eventBatchQueueItem, S.error> => {
  let module(Event) = eventMod->(Utils.magic: module(Types.Event) => module(Types.Event with type eventArgs = eventArgs))
  rawEvent.params
  ->S.parseJsonStringWith(Event.eventArgsSchema)
  ->Belt.Result.map(params => {
    let event = {
      chainId: rawEvent.chainId,
      txOrigin,
      txTo,
      blockNumber: rawEvent.blockNumber,
      blockTimestamp: rawEvent.blockTimestamp,
      blockHash: rawEvent.blockHash,
      srcAddress: rawEvent.srcAddress,
      transactionHash: rawEvent.transactionHash,
      transactionIndex: rawEvent.transactionIndex,
      logIndex: rawEvent.logIndex,
      params,
    }->eventAccessor

    let queueItem: Types.eventBatchQueueItem = {
      event,
      eventMod,
      timestamp: rawEvent.blockTimestamp,
      chain,
      blockNumber: rawEvent.blockNumber,
      logIndex: rawEvent.logIndex,
    }

    queueItem
  })
}


let parseRawEvent = (
  rawEvent: TablesStatic.RawEvents.t,
  ~chain,
  ~txOrigin: option<Ethers.ethAddress>,
  ~txTo: option<Ethers.ethAddress>,
): result<Types.eventBatchQueueItem, S.error> => {
  switch rawEvent.eventType {
  {{#each codegen_contracts as |contract|}}
  {{#each contract.codegen_events as |event|}}
    | {{event.event_type.full}} =>
      rawEvent->decodeRawEventWith(
        ~eventMod=module(Types.{{contract.name.capitalized}}.{{event.name.capitalized}}),
        ~eventAccessor=event => Types.{{contract.name.capitalized}}_{{event.name.capitalized}}(event),
        ~chain,
        ~txOrigin,
        ~txTo,
      )
  {{/each}}
  {{/each}}
  }
}
