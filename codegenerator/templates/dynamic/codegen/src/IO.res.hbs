module InMemoryStore = {

  let entityCurrentCrud = (currentCrud: option<Types.crud>, nextCrud: Types.crud) => {

     switch (currentCrud, nextCrud) {
    | (Some(Create), Create) => Types.Create
    | (Some(Read), Create)
    | (Some(Update), Create)
    | (Some(Delete), Create) =>
      // dont know if this is an update or create
      Update
    | (Some(Create), Read) => Create
    | (Some(Read), Read) => Read
    | (Some(Update), Read) => Update
    | (Some(Delete), Read) => Delete
    | (Some(Create), Update) => Create
    | (Some(Read), Update) => Update
    | (Some(Update), Update) => Update
    | (Some(Delete), Update) => Update
    | (Some(Create), Delete) => Delete // interesting to note to line 23
    | (Some(Read), Delete) => Delete
    | (Some(Update), Delete) => Delete
    | (Some(Delete), Delete) => Delete
    | (None, _) => nextCrud
    }
  }

  module RawEvents = {
    let rawEventsDict: ref<Js.Dict.t<Types.inMemoryStoreRow<Types.rawEventsEntity>>> = ref(
      Js.Dict.empty(),
    )

    let getRawEvents = (~id: string) => {
      let row = Js.Dict.get(rawEventsDict.contents, id)
      row->Belt.Option.map(row => row.entity)
    }

    let setRawEvents = (~entity: Types.rawEventsEntity, ~crud: Types.crud) => {
      let key = EventUtils.getEventIdKeyString(
        ~chainId=entity.chainId,
        ~eventId=entity.eventId,
      )
      let rawEventCurrentCrud =
        rawEventsDict.contents
        ->Js.Dict.get(key)
        ->Belt.Option.map(row => {
          row.crud
        })

      rawEventsDict.contents->Js.Dict.set(
        key,
        {eventData: {chainId: entity.chainId, eventId: entity.eventId}, entity, crud: entityCurrentCrud(rawEventCurrentCrud, crud)},
      )
    }   
  }
  module DynamicContractRegistry = {
      let dynamicContractRegistryDict: ref<Js.Dict.t<Types.inMemoryStoreRow<Types.dynamicContractRegistryEntity>>> = ref(
        Js.Dict.empty(),
      )

      let getDynamicContractRegistry = (~id: string) => {
        let row = Js.Dict.get(dynamicContractRegistryDict.contents, id)
        row->Belt.Option.map(row => row.entity)
      }

      let setDynamicContractRegistry = (~entity: Types.dynamicContractRegistryEntity, ~crud: Types.crud) => {
        let key = EventUtils.getContractAddressKeyString(
          ~chainId=entity.chainId,
          ~contractAddress=entity.contractAddress,
        )
        let dynamicContractRegistryCurrentCrud =
          dynamicContractRegistryDict.contents
          ->Js.Dict.get(key)
          ->Belt.Option.map(row => {
            row.crud
          })

        dynamicContractRegistryDict.contents->Js.Dict.set(
          key,
          {eventData: {chainId: entity.chainId, eventId: entity.eventId->Ethers.BigInt.toString}, entity, crud: entityCurrentCrud(dynamicContractRegistryCurrentCrud, crud)},
        )
      }
    }

{{#each entities as | entity |}}

module {{entity.name.capitalized}} = {
  let {{entity.name.uncapitalized}}Dict: ref<Js.Dict.t<Types.inMemoryStoreRow<Types.{{entity.name.uncapitalized}}Entity>>> = ref(
    Js.Dict.empty(),
  )

  let get{{entity.name.capitalized}} = (~id: string) => {
    let row = Js.Dict.get({{entity.name.uncapitalized}}Dict.contents, id)
    row->Belt.Option.map(row => row.entity)
  }

  let set{{entity.name.capitalized}} = (~entity: Types.{{entity.name.uncapitalized}}Entity, ~crud: Types.crud, ~eventData: Types.eventData) => {
    let {{entity.name.uncapitalized}}CurrentCrud = Js.Dict.get(
      {{entity.name.uncapitalized}}Dict.contents,
      entity.id,
    )->Belt.Option.map(row => {
      row.crud
    })



    {{entity.name.uncapitalized}}Dict.contents->Js.Dict.set(entity.id, {eventData, entity, crud: entityCurrentCrud({{entity.name.uncapitalized}}CurrentCrud, crud)})
  }
  }
  {{/each}}
  let resetStore = () => {
  {{#each entities as | entity |}}
    {{entity.name.capitalized}}.{{entity.name.uncapitalized}}Dict := Js.Dict.empty()
  {{/each}}
  }
}

type uniqueEntityReadIds = Js.Dict.t<Types.id>
type allEntityReads = Js.Dict.t<uniqueEntityReadIds>

let loadEntities = async (sql, entityBatch: array<Types.entityRead>) => {
  let loadLayer = ref(false)

  {{#each entities as | entity |}}
  let unique{{entity.name.capitalized}}Dict = Js.Dict.empty()
  {{/each}}

  // TODO: don't create an array if the entity doesn't have any entity relation fields.
  {{#each entities as | entity |}}
  let populate{{entity.name.capitalized}}LoadAsEntityFunctions: array<unit => unit> = []
  {{/each}}

  let populateLoadAsEntityFunctions: ref<array<unit => unit>> = ref([])

  {{#each entities as | entity |}}
  let unique{{entity.name.capitalized}}AsEntityFieldArray: array<string> = []
  {{/each}}

  let rec{{#each entities as | entity |}}{{#unless @first}} and {{/unless}} {{entity.name.uncapitalized}}LinkedEntityLoader = (
    entityId: string,
    {{#if entity.relational_params.[0]}}{{entity.name.uncapitalized}}Load: Types.{{entity.name.uncapitalized}}LoaderConfig,{{/if}}
    layer: int,
  ) => {
    if (!loadLayer.contents) {
      // NOTE: Always set this to true if it is false, I'm sure there are optimizations. Correctness over optimization for now.
      loadLayer := true
    }
    if Js.Dict.get(unique{{entity.name.capitalized}}Dict, entityId)->Belt.Option.isNone {
      let _ = unique{{entity.name.capitalized}}AsEntityFieldArray->Js.Array2.push(entityId)
      let _ = Js.Dict.set(unique{{entity.name.capitalized}}Dict, entityId, entityId)
    }

    {{#each entity.relational_params as | relational_param |}}
    switch {{entity.name.uncapitalized}}Load.load{{relational_param.relational_key.capitalized}} {
    | Some(load{{relational_param.mapped_entity.capitalized}}) =>
      let _ = populateLoadAsEntityFunctions.contents->Js.Array2.push(() => {
        let _ = InMemoryStore.{{entity.name.capitalized}}.get{{entity.name.capitalized}}(~id=entityId)->Belt.Option.map(
          {{entity.name.uncapitalized}}Entity => {
            {{#if (eq relational_param.relationship_type "array")}}
              let _ = {{entity.name.uncapitalized}}Entity.{{relational_param.relational_key.uncapitalized}}->Belt.Array.map(
                    {{relational_param.relational_key.uncapitalized}}Id =>
                {{relational_param.mapped_entity.uncapitalized}}LinkedEntityLoader({{relational_param.relational_key.uncapitalized}}Id, {{#each ../../entities as | internal_entity |}}{{#if (eq internal_entity.name.capitalized relational_param.mapped_entity.capitalized)}}{{#if internal_entity.relational_params.[0]}}load{{relational_param.mapped_entity.capitalized}}, {{/if}}{{/if}}{{/each}}layer + 1)
              )
            {{else}}
              {{#if relational_param.is_optional}}
                let _ = {{entity.name.uncapitalized}}Entity.{{relational_param.relational_key.uncapitalized}}->Belt.Option.map(
                  {{relational_param.relational_key.uncapitalized}}Id =>
                    {{relational_param.mapped_entity.uncapitalized}}LinkedEntityLoader({{relational_param.relational_key.uncapitalized}}Id, {{#each ../../entities as | internal_entity |}}{{#if (eq internal_entity.name.capitalized relational_param.mapped_entity.capitalized)}}{{#if internal_entity.relational_params.[0]}}load{{relational_param.mapped_entity.capitalized}}, {{/if}}{{/if}}{{/each}}layer + 1)
                )
              {{else}}
                let _ = {{relational_param.mapped_entity.uncapitalized}}LinkedEntityLoader({{entity.name.uncapitalized}}Entity.{{relational_param.relational_key.uncapitalized}}, {{#each ../../entities as | internal_entity |}}{{#if (eq internal_entity.name.capitalized relational_param.mapped_entity.capitalized)}}{{#if internal_entity.relational_params.[0]}}load{{relational_param.mapped_entity.capitalized}}, {{/if}}{{/if}}{{/each}}layer + 1)
              {{/if}}
            {{/if}}
          })
      })
    | None => ()
    }
    {{/each}}
    ()
  }{{/each}}

  entityBatch->Belt.Array.forEach(readEntity => {
        switch readEntity {
    {{#each entities as | entity |}}
    | {{entity.name.capitalized}}Read(entityId{{#if entity.relational_params.[0]}}, {{entity.name.uncapitalized}}Load{{/if}}) =>
      {{entity.name.uncapitalized}}LinkedEntityLoader(entityId{{#if entity.relational_params.[0]}}, {{entity.name.uncapitalized}}Load{{/if}}, 0)
    {{/each}}
    }
  })

  {{#each entities as | entity |}}
  if Js.Dict.keys(unique{{entity.name.capitalized}}Dict)->Array.length > 0 {
    let {{entity.name.uncapitalized}}EntitiesArray = await sql->DbFunctions.{{entity.name.capitalized}}.read{{entity.name.capitalized}}Entities(
      Js.Dict.values(unique{{entity.name.capitalized}}Dict),
    )

    {{entity.name.uncapitalized}}EntitiesArray->Belt.Array.forEach((readRow) =>
      {
        let {entity, eventData} = DbFunctions.{{entity.name.capitalized}}.readRowToReadEntityData(readRow)
        InMemoryStore.{{entity.name.capitalized}}.set{{entity.name.capitalized}}(~entity, ~eventData, ~crud=Types.Read)
      }
    )
  }

  {{/each}}

  // Execute first layer of additional load functions:
  // TODO: make this a recursive process
  {{#each entities as | entity |}}
  populate{{entity.name.capitalized}}LoadAsEntityFunctions->Belt.Array.forEach(func => func())
  {{/each}}

  {{#each entities as | entity |}}
    if unique{{entity.name.capitalized}}AsEntityFieldArray->Array.length > 0 {
      let {{entity.name.uncapitalized}}FieldEntitiesArray =
        await sql->DbFunctions.{{entity.name.capitalized}}.read{{entity.name.capitalized}}Entities(unique{{entity.name.capitalized}}AsEntityFieldArray)

      {{entity.name.uncapitalized}}FieldEntitiesArray->Belt.Array.forEach(readRow => {
        let {entity, eventData} = DbFunctions.{{entity.name.capitalized}}.readRowToReadEntityData(readRow)
        InMemoryStore.{{entity.name.capitalized}}.set{{entity.name.capitalized}}(~entity, ~eventData, ~crud=Types.Read)
      })
    }
  {{/each}}
}

let executeBatch = async (sql) => {
  let rawEventsRows = InMemoryStore.RawEvents.rawEventsDict.contents->Js.Dict.values

  let deleteRawEventsIdsPromise = (sql) => {
    let deleteRawEventsIds =
      rawEventsRows
      ->Belt.Array.keepMap(rawEventsRow =>
        rawEventsRow.crud == Types.Delete ? Some(rawEventsRow.entity) : None
      )
      ->Belt.Array.map(rawEvents =>
      (rawEvents.chainId, rawEvents.eventId)
      )

    if deleteRawEventsIds->Belt.Array.length > 0 {
      sql->DbFunctions.RawEvents.batchDeleteRawEvents(deleteRawEventsIds)
    } else {
      ()->Promise.resolve
    }
  }

  let setRawEventsPromise = (sql) => {
    let setRawEvents =
      rawEventsRows->Belt.Array.keepMap(rawEventsRow =>
        rawEventsRow.crud == Types.Create || rawEventsRow.crud == Update
          ? Some(rawEventsRow.entity)
          : None
      )

    if setRawEvents->Belt.Array.length > 0 {
      sql->DbFunctions.RawEvents.batchSetRawEvents(setRawEvents)
    } else {
      ()->Promise.resolve
    }
  }

  let dynamicContractRegistryRows = InMemoryStore.DynamicContractRegistry.dynamicContractRegistryDict.contents->Js.Dict.values

  let deleteDynamicContractRegistryIdsPromise = (sql) => {
    let deleteDynamicContractRegistryIds =
      dynamicContractRegistryRows
      ->Belt.Array.keepMap(dynamicContractRegistryRow =>
        dynamicContractRegistryRow.crud == Types.Delete ? Some(dynamicContractRegistryRow.entity) : None
      )
      ->Belt.Array.map(dynamicContractRegistry => (
        dynamicContractRegistry.chainId,
        dynamicContractRegistry.contractAddress,
      ))

    if deleteDynamicContractRegistryIds->Belt.Array.length > 0 {
      sql->DbFunctions.DynamicContractRegistry.batchDeleteDynamicContractRegistry(deleteDynamicContractRegistryIds)
    } else {
      ()->Promise.resolve
    }
  }

  let setDynamicContractRegistryPromise = (sql) => {
    let setDynamicContractRegistry =
      dynamicContractRegistryRows->Belt.Array.keepMap(dynamicContractRegistryRow =>
        dynamicContractRegistryRow.crud == Types.Create || dynamicContractRegistryRow.crud == Update
          ? Some(dynamicContractRegistryRow.entity)
          : None
      )

    if setDynamicContractRegistry->Belt.Array.length > 0 {
      sql->DbFunctions.DynamicContractRegistry.batchSetDynamicContractRegistry(setDynamicContractRegistry)
    } else {
      ()->Promise.resolve
    }
  }

  {{#each entities as | entity |}}
  let {{entity.name.uncapitalized}}Rows = InMemoryStore.{{entity.name.capitalized}}.{{entity.name.uncapitalized}}Dict.contents->Js.Dict.values

  let delete{{entity.name.capitalized}}IdsPromise = (sql) => {
    let delete{{entity.name.capitalized}}Ids =
      {{entity.name.uncapitalized}}Rows
      ->Belt.Array.keepMap({{entity.name.uncapitalized}}Row =>
        {{entity.name.uncapitalized}}Row.crud == Types.Delete ? Some({{entity.name.uncapitalized}}Row.entity) : None
      )
      ->Belt.Array.map({{entity.name.uncapitalized}} => {{entity.name.uncapitalized}}.id)

      if delete{{entity.name.capitalized}}Ids->Belt.Array.length > 0 {
        sql->DbFunctions.{{entity.name.capitalized}}.batchDelete{{entity.name.capitalized}}(delete{{entity.name.capitalized}}Ids)
      } else {
        ()->Promise.resolve
      }
  }
  let set{{entity.name.capitalized}}Promise = (sql) => {
    let set{{entity.name.capitalized}} =
      {{entity.name.uncapitalized}}Rows->Belt.Array.keepMap({{entity.name.uncapitalized}}Row =>
        {{entity.name.uncapitalized}}Row.crud == Types.Create || {{entity.name.uncapitalized}}Row.crud == Update
          ? Some({
            ...{{entity.name.uncapitalized}}Row,
            entity: {{entity.name.uncapitalized}}Row.entity->Types.serialize{{entity.name.capitalized}}Entity,
          }) 
          : None
      )

      if set{{entity.name.capitalized}}->Belt.Array.length > 0 {
         sql->DbFunctions.{{entity.name.capitalized}}.batchSet{{entity.name.capitalized}}(set{{entity.name.capitalized}})
      } else {
        ()->Promise.resolve
      }
  }

  {{/each}}

  let res = await sql->Postgres.beginSql((sql)=>{
     [
      sql->deleteRawEventsIdsPromise,
      sql->setRawEventsPromise,
      sql->deleteDynamicContractRegistryIdsPromise,
      sql->setDynamicContractRegistryPromise,
      {{#each entities as | entity |}}
      sql->delete{{entity.name.capitalized}}IdsPromise,
      sql->set{{entity.name.capitalized}}Promise,
      {{/each}}
    ]
  })

  res
}
